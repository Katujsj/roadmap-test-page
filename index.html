<div id="roadmap-app" data-title="Interactive Roadmap"></div>

<style>
  /* Layout */
  #roadmap-app { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif; }
  .rm-toolbar { display:flex; gap:8px; align-items:center; padding:10px; border:1px solid #e5e7eb; border-radius:12px; margin:8px 0 12px; background:#fafafa; }
  .rm-toolbar > * { font-size:12px; }
  .rm-btn { padding:6px 10px; border:1px solid #e5e7eb; border-radius:10px; background:#fff; cursor:pointer; }
  .rm-btn:hover { background:#f5f5f5; }
  .rm-select, .rm-input { padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; }
  .rm-dropdown { position:relative; }
  .rm-dropdown__toggle::after { content:'\25BE'; margin-left:4px; font-size:10px; }
  .rm-dropdown__menu { position:absolute; right:0; top:calc(100% + 4px); background:#fff; border:1px solid #e5e7eb; border-radius:10px; box-shadow:0 8px 16px rgba(15,23,42,0.12); padding:4px; min-width:140px; display:none; z-index:30; }
  .rm-dropdown.open .rm-dropdown__menu { display:flex; flex-direction:column; gap:2px; }
  .rm-dropdown__item { padding:6px 10px; border-radius:8px; border:none; background:transparent; text-align:left; font-size:12px; cursor:pointer; }
  .rm-dropdown__item:hover { background:#f5f5f5; }
  .rm-container { --laneColWidth:220px; border:1px solid #e5e7eb; border-radius:12px; overflow:hidden; }
  /* Fullscreen adjustments */
  .rm-container:fullscreen { width:100vw; height:100vh; background:#fff; }
  .rm-container:fullscreen .rm-grid { max-height: calc(100vh - 86px); height: calc(100vh - 86px); }
  .rm-container:fullscreen .rm-canvaswrap { overflow:auto; }
  .rm-root:fullscreen { width:100vw; height:100vh; background:#fff; }
  .rm-root:fullscreen .rm-container { width:100vw; }
  .rm-root:fullscreen .rm-grid { max-height: calc(100vh - 86px); height: calc(100vh - 86px); }
  .rm-root:fullscreen .rm-canvaswrap { overflow:auto; }

  /* Header */
  .rm-header { display:grid; grid-template-columns:var(--laneColWidth) 6px 1fr; background:#fcfcfd; border-bottom:1px solid #eee; }
  .rm-header .rm-left { padding:10px 12px; font-weight:600; color:#111; }
  .rm-header .rm-scale { position:relative; border-left:1px solid #eee; overflow:hidden; }
  .rm-header-resizer { position:relative; width:6px; pointer-events:none; }
  .rm-header-resizer::after { content:''; position:absolute; top:0; bottom:0; left:50%; width:2px; transform:translateX(-50%); border-radius:1px; background:#e5e7eb; }

  /* Grid: lanes 고정, canvas만 가로 스크롤 */
  .rm-grid { display:grid; grid-template-columns:var(--laneColWidth) 6px 1fr; overflow-y:visible; overflow-x:hidden; }
  .rm-laneswrap { overflow:hidden; grid-column:1; }
  .rm-resizer { position:relative; width:6px; cursor:col-resize; grid-column:2; }
  .rm-canvaswrap { grid-column:3; }
  .rm-resizer::after { content:''; position:absolute; top:0; bottom:0; left:50%; width:2px; transform:translateX(-50%); border-radius:1px; background:#e5e7eb; transition:background 0.2s; }
  .rm-resizer:hover::after, .rm-resizer.dragging::after { background:#6366f1; }
  .rm-canvaswrap { overflow-x:auto; overflow-y:hidden; }
  .rm-lanes { border-right:1px solid #eee; position:relative; } /* DnD 가이드라인을 위해 relative */
  .rm-lane { display:flex; align-items:center; gap:6px; padding:8px 10px; border-bottom:1px solid #f1f1f1; background:#fff; box-sizing:border-box; }
  .rm-lane input { border:1px solid #e5e7eb; border-radius:8px; padding:6px 8px; flex:1 1 auto; width:auto; min-width:0; }
  .rm-lane .rm-color { width:18px; height:18px; border-radius:6px; border:1px solid #e5e7eb; cursor:pointer; }
  .rm-lane .rm-treepad { width:0; height:0; }
  .rm-milestone-toggle { display:flex; align-items:center; gap:4px; font-size:11px; color:#4b5563; white-space:nowrap; margin-right:4px; flex-shrink:0; }
  .rm-milestone-toggle input { margin:0; }
  .rm-expander { width:18px; height:18px; border:1px solid #e5e7eb; border-radius:6px; background:#fff; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:12px; line-height:1; }

  /* Drag handle & insert guide */
  .rm-drag { width:14px; height:18px; display:flex; align-items:center; justify-content:center; cursor:grab; color:#9ca3af; user-select:none; }
  .rm-drag:active { cursor:grabbing; }
  .rm-insert-line { position:absolute; left:6px; right:6px; height:2px; background:#6366f1; border-radius:2px; pointer-events:none; z-index:5; }

  .rm-canvas { position:relative; background:linear-gradient(#fff,#fff) padding-box; min-height:280px; }
  .rm-row { position:relative; border-bottom:1px dashed #f0f0f0; box-sizing:border-box; }

  /* Ticks + Weekend bands */
  .rm-weekend-head { position:absolute; inset:0; z-index:0; pointer-events:none; }
  .rm-ticks { position:relative; height:30px; will-change:transform; z-index:1; }
  .rm-tick { position:absolute; top:0; height:100%; border-left:1px solid #eee; font-size:11px; color:#555; padding-left:2px; white-space:pre; }

  /* Tasks */
  .rm-task { position:absolute; height:28px; top:8px; border-radius:8px; box-shadow:0 1px 0 rgba(0,0,0,0.05), 0 1px 6px rgba(0,0,0,0.05); display:flex; align-items:center; z-index:2; }
  .rm-task.sel { outline:2px solid #6366f1; outline-offset:1px; }
  .rm-task .rm-label { font-size:12px; padding:0 8px; color:#111; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .rm-handle { position:absolute; top:0; width:8px; height:100%; cursor:ew-resize; }
  .rm-handle.left { left:-4px; }
  .rm-handle.right { right:-4px; }
  .rm-task--milestone { background:transparent; box-shadow:none; transform:translateX(-50%); }
  .rm-task--milestone .rm-milestone-shape { position:absolute; top:50%; left:50%; width:14px; height:14px; transform:translate(-50%,-50%) rotate(45deg); border-radius:4px; box-shadow:0 1px 4px rgba(0,0,0,0.1); }
  .rm-task--milestone .rm-milestone-label { position:absolute; top:50%; left:calc(50% + 14px); transform:translateY(-50%); display:flex; align-items:center; gap:6px; font-size:12px; color:#111; white-space:nowrap; pointer-events:auto; }
  .rm-task--milestone .rm-milestone-title { font-weight:500; }
  .rm-task--milestone .rm-milestone-date { font-size:11px; color:#4b5563; }

  /* Weekend in canvas */
  .rm-weekends-layer { position:absolute; inset:0; z-index:0; pointer-events:none; }
  .rm-weekend-block { position:absolute; top:0; bottom:0; background:#f3f4f6; }

  /* Rollup(자식 일정 묶음) */
  .rm-roll { position:absolute; height:6px; border-radius:4px; pointer-events:none; z-index:1; }
  .rm-roll.busy { opacity:.9; }
  .rm-roll.gap  { background:#4b5563; opacity:.6; }

  /* Selection */
  .rm-row.sel, .rm-lane.sel { background:#f8fafc; }
  .rm-pill { padding:4px 8px; background:#eef2ff; color:#4338ca; border-radius:999px; font-size:11px; margin-left:6px; }
  .rm-note { font-size:12px; color:#666; margin-left:8px; }
  .rm-danger { color:#b91c1c; }
  .rm-muted { color:#6b7280; }

  /* Today markers */
  .rm-today-head, .rm-today-line { position:absolute; top:0; width:2px; background:#ef4444; pointer-events:none; opacity:0.8; z-index:3; }
  .rm-today-head { height:100%; }
  .rm-today-line { bottom:0; }

  /* Tooltip */
  .rm-tip { position:fixed; padding:8px 10px; border:1px solid #e5e7eb; background:#fff; border-radius:10px; box-shadow:0 8px 24px rgba(0,0,0,.08); font-size:12px; color:#111; pointer-events:none; z-index:2147480000; white-space:nowrap; }
  .rm-context-menu { position:fixed; z-index:2147481000; background:#fff; border:1px solid #e5e7eb; border-radius:10px; box-shadow:0 12px 32px rgba(15,23,42,0.12); padding:4px 0; display:inline-flex; flex-direction:column; }
  .rm-context-menu button { display:flex; align-items:center; padding:8px 12px; border:none; background:transparent; text-align:left; font-size:12px; color:#111; cursor:pointer; white-space:nowrap; }
  .rm-context-menu button:hover { background:#f3f4f6; }
  .rm-context-menu button:disabled { color:#9ca3af; cursor:default; background:transparent; }
  .rm-context-sep { margin:4px 0; border-top:1px solid #e5e7eb; }
  .rm-resize-guide { position:fixed; width:2px; background:#6366f1; top:0; bottom:0; pointer-events:none; z-index:2147481500; border-radius:1px; }

  /* Modal */
  .rm-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.32); display:flex; align-items:center; justify-content:center; z-index:2147483000; }
  .rm-modal { width:420px; max-width:92vw; background:#fff; border:1px solid #e5e7eb; border-radius:16px; box-shadow:0 12px 36px rgba(15,23,42,0.16); max-height:80vh; overflow:auto; }
  .rm-modal header { padding:16px 20px; border-bottom:1px solid #eee; font-weight:600; font-size:14px; }
  .rm-modal .rm-body { padding:16px 18px; display:grid; grid-template-columns:96px minmax(0,1fr); gap:12px 10px; align-items:center; }
  .rm-modal .rm-body label { font-size:12px; color:#374151; font-weight:500; padding-top:0; }
  .rm-modal .rm-body input[type="text"], .rm-modal .rm-body input[type="date"] { border:1px solid #e5e7eb; border-radius:10px; padding:8px 11px; font-size:13px; width:100%; max-width:100%; min-width:0; box-sizing:border-box; background:#fff; }
  .rm-modal .rm-body input[type="text"]::placeholder { color:#9ca3af; }
  .rm-modal .rm-body input[type="date"] { cursor:pointer; position:relative; }
  .rm-modal .rm-body input[type="date"]::-webkit-calendar-picker-indicator {
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    margin:0;
    opacity:0;
    cursor:pointer;
  }
  .rm-modal .rm-body input[type="date"]::-webkit-inner-spin-button,
  .rm-modal .rm-body input[type="date"]::-webkit-clear-button { display:none; }
  .rm-modal .rm-body .rm-date-range { display:flex; align-items:center; gap:8px; }
  .rm-modal .rm-body .rm-date-range input[type="date"] { flex:1 1 0; min-width:0; }
  .rm-modal .rm-body .rm-date-range span { color:#6b7280; font-size:13px; }
  .rm-modal .rm-body .rm-option-group { display:flex; flex-direction:column; gap:8px; }
  .rm-modal .rm-body .rm-option-row { display:flex; align-items:center; gap:10px; font-size:12px; color:#374151; }
  .rm-modal .rm-body .rm-option-row input[type="checkbox"] { margin:0; }
  .rm-modal .rm-body .rm-color-picker { width:38px; height:26px; padding:0; border:none; background:transparent; cursor:pointer; border-radius:8px; }
  .rm-modal footer { display:flex; justify-content:flex-end; gap:10px; padding:14px 20px; border-top:1px solid #eee; background:#f9fafb; border-radius:0 0 16px 16px; }
  .rm-modal .rm-btn { padding:9px 16px; border-radius:12px; }
</style>

<script type="text/javascript">
  /* 커스텀 로드맵 v0.2*/
/*<![CDATA[*/
(function () {
  var el = document.getElementById('roadmap-app');
  if (!el) return;

  /* ========= Utilities ========= */
  var byId = function(id){ return document.getElementById(id); };
  // Local-safe YYYY-MM-DD formatter (avoid timezone shifting)
  var fmt = function(d){
    var x = new Date(d);
    var y = x.getFullYear();
    var m = ('0' + (x.getMonth() + 1)).slice(-2);
    var dd = ('0' + x.getDate()).slice(-2);
    return y + '-' + m + '-' + dd;
  };
  var today = function(){ return new Date(new Date().toDateString()); };
  var addDays = function(d, n){ var x=new Date(d); x.setDate(x.getDate()+n); return x; };
  var startOfMonth = function(d){ return new Date(d.getFullYear(), d.getMonth(), 1); };
  var endOfMonth = function(d){ return new Date(d.getFullYear(), d.getMonth()+1, 0); };
  var ceilToMonday = function(d){ var x=new Date(d); var w=(x.getDay()+6)%7; x.setDate(x.getDate()-w); return x; };
  var startOfQuarter = function(d){ return new Date(d.getFullYear(), Math.floor(d.getMonth()/3)*3, 1); };
  var endOfQuarter = function(d){ return new Date(d.getFullYear(), Math.floor(d.getMonth()/3)*3 + 3, 0); };
  var startOfYear = function(d){ return new Date(d.getFullYear(), 0, 1); };
  var endOfYear = function(d){ return new Date(d.getFullYear()+1, 0, 0); };

  /* Confluence-safe HTML escape */
  function escapeHtml(s) {
    s = String(s == null ? '' : s);
    return s
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, "&#39;");
  }

  function makeId(){
    try{ if (window.crypto && crypto.randomUUID) return crypto.randomUUID(); }catch(e){}
    return 'id-' + Math.random().toString(36).slice(2) + Date.now();
  }

  function getPageId(){
    var meta = document.querySelector("meta[name='ajs-page-id']");
    return meta ? meta.getAttribute('content') : null;
  }
  function getBasePath(){
    var meta = document.querySelector('meta[name="ajs-context-path"]') || document.querySelector('meta[name="confluence-context-path"]');
    var fromMeta = meta ? meta.getAttribute('content') : '';
    var fromAJS = (window.AJS && AJS.params && AJS.params.contextPath) ? AJS.params.contextPath : '';
    return fromMeta || fromAJS || '';
  }
  var BASE = getBasePath();

  function isTypingContext(){
    var ae = document.activeElement;
    if (!ae) return false;
    return ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable;
  }

  /* ========= State & History ========= */
  var PAGE_ID = getPageId() || 'no-page';
  var LS_KEY = 'roadmap:' + PAGE_ID;
  var ATT_NAME = 'roadmap-' + PAGE_ID + '.json';

  var DEFAULT = {
    scale: 'week',
    start: fmt(addDays(ceilToMonday(today()), -7)),
    end:   fmt(addDays(ceilToMonday(today()), 28)),
    lanes: [
      { id: makeId(), name: 'Lane 1', color:'#c7d2fe', parentId: null, collapsed:false, milestone:false },
      { id: makeId(), name: 'Lane 2', color:'#bbf7d0', parentId: null, collapsed:false, milestone:false }
    ],
    tasks: [],
    laneWidth: 220
  };

  var state = JSON.parse(JSON.stringify(DEFAULT));
  var selectedLaneId = null;
  var selectedTaskId = null; // legacy primary selection
  var selectedTaskIds = [];
  var modalOpen = false;
  var laneResizeInfo = null;
  var LANE_MIN_WIDTH = 160;
  var LANE_MAX_WIDTH = 720;

  var undoStack = [];
  var redoStack = [];
  var MAX_UNDO = 100;
  var snapshot = function(){
    return {
      state: JSON.parse(JSON.stringify(state)),
      selectedLaneId: selectedLaneId,
      selectedTaskId: selectedTaskId,
      selectedTaskIds: selectedTaskIds.slice()
    };
  };
  function pushUndo(){ undoStack.push(snapshot()); if (undoStack.length>MAX_UNDO) undoStack.shift(); redoStack.length = 0; }
  function applySnap(snap){
    state = JSON.parse(JSON.stringify(snap.state));
    selectedLaneId = snap.selectedLaneId;
    selectedTaskId = snap.selectedTaskId;
    selectedTaskIds = Array.isArray(snap.selectedTaskIds) ? snap.selectedTaskIds.slice() : (selectedTaskId ? [selectedTaskId] : []);
    markDirty('Autosaved');
    render();
  }
  function doUndo(){ if (!undoStack.length) return; var curr=snapshot(); var prev=undoStack.pop(); redoStack.push(curr); applySnap(prev); }
  function doRedo(){ if (!redoStack.length) return; var curr=snapshot(); var next=redoStack.pop(); undoStack.push(curr); applySnap(next); }

  /* ========= Storage ========= */
  function loadFromAttachment(){
    var pageId = getPageId(); if (!pageId) return Promise.resolve(null);
    return fetch(BASE + '/rest/api/content/' + pageId + '/child/attachment?filename=' + encodeURIComponent(ATT_NAME))
      .then(function(res){ return res.ok ? res.json() : null; })
      .then(function(j){ if (!j) return null; var att = j.results && j.results[0]; if (!att) return null; var dl = att._links && att._links.download; return dl ? fetch(BASE + dl, { credentials:'same-origin' }) : null; })
      .then(function(file){ return file && file.ok ? file.text() : null; })
      .then(function(text){ return text ? JSON.parse(text) : null; })
      .catch(function(){ return null; });
  }
  function loadFromLocal(){ try{ var t = localStorage.getItem(LS_KEY); return t? JSON.parse(t): null; }catch(e){ return null; } }
  function saveToLocal(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){} }
  function saveToAttachment(){
    var pageId = getPageId(); if (!pageId) return Promise.reject(new Error('No pageId'));
    return fetch(BASE + '/rest/api/content/' + pageId + '/child/attachment?filename=' + encodeURIComponent(ATT_NAME))
      .then(function(res){ return res.ok ? res.json() : {results:[]}; })
      .then(function(j){ var attId = (j.results && j.results[0] && j.results[0].id) || null;
        var blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
        var form = new FormData(); form.append('file', blob, ATT_NAME);
        var url = attId ? (BASE + '/rest/api/content/' + pageId + '/child/attachment/' + attId + '/data') : (BASE + '/rest/api/content/' + pageId + '/child/attachment');
        return fetch(url, { method:'POST', body:form, headers:{'X-Atlassian-Token':'no-check'}, credentials:'same-origin' });
      })
      .then(function(res){ if (!res.ok) throw new Error('Attachment save failed: ' + res.status); });
  }

  function exportStateAsFile(){
    try {
      var serialized = JSON.stringify(state, null, 2);
      var blob = new Blob([serialized], { type: 'application/json' });
      var url = URL.createObjectURL(blob);
      var base = ATT_NAME ? ATT_NAME.replace(/\.json$/, '') : 'roadmap-data';
      var stamp = new Date().toISOString().replace(/[:.]/g, '-');
      var filename = base + '-export-' + stamp.slice(0, 19) + '.json';
      var link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      setTimeout(function(){ document.body.removeChild(link); URL.revokeObjectURL(url); }, 0);
    } catch (err) {
      console.error(err);
      alert('데이터 내보내기에 실패했습니다. 콘솔을 확인해주세요.');
    }
  }

  /* ========= Data Import (CSV / JSON) ========= */
  function parseCSV(text){
    var rows = [], row = [], i=0, s=text, len=s.length, ch, val='', inQ=false;
    function pushCell(){ row.push(val); val=''; }
    function pushRow(){ rows.push(row); row=[]; }
    for(i=0;i<len;i++){
      ch = s[i];
      if (inQ){
        if (ch==='"'){
          if (i+1<len && s[i+1]==='"'){ val+='"'; i++; }
          else { inQ=false; }
        } else { val+=ch; }
      } else {
        if (ch==='"'){ inQ=true; }
        else if (ch===','){ pushCell(); }
        else if (ch==='\n'){ pushCell(); pushRow(); }
        else if (ch==='\r'){ /* ignore */ }
        else { val+=ch; }
      }
    }
    pushCell(); pushRow();
    if (rows.length && rows[rows.length-1].length===1 && rows[rows.length-1][0]==='') rows.pop();
    var headers = rows.shift() || [];
    return { headers: headers, rows: rows };
  }

  function parseJSONTable(text){
    var data;
    try {
      data = JSON.parse(text);
    } catch (err) {
      alert('JSON 파싱에 실패했습니다: ' + (err && err.message ? err.message : '')); return null;
    }
    var arr = [];
    if (Array.isArray(data)){
      arr = data;
    } else if (data && typeof data === 'object'){ // roadmap state 저장 포맷 지원
      if (Array.isArray(data.tasks)){
        var lanesById = {};
        if (Array.isArray(data.lanes)){
          for (var li=0; li<data.lanes.length; li++){
            var lane = data.lanes[li];
            if (lane && lane.id) lanesById[lane.id] = lane;
          }
        }
        for (var ti=0; ti<data.tasks.length; ti++){
          var task = data.tasks[ti];
          if (!task || typeof task !== 'object') continue;
          var clone = {};
          Object.keys(task).forEach(function(k){ clone[k] = task[k]; });
          if (clone.lane == null && clone.laneId && lanesById[clone.laneId] && lanesById[clone.laneId].name){
            clone.lane = lanesById[clone.laneId].name;
          }
          arr.push(clone);
        }
      }
    }
    if (!Array.isArray(arr)){
      alert('지원하지 않는 JSON 구조입니다. 배열 또는 tasks 배열이 필요합니다.');
      return null;
    }
    var headers = [];
    var rows = [];
    for (var i=0;i<arr.length;i++){
      var item = arr[i];
      if (!item || typeof item !== 'object') continue;
      Object.keys(item).forEach(function(k){ if (headers.indexOf(k)===-1) headers.push(k); });
    }
    if (!headers.length) return { headers:[], rows:[] };
    for (var j=0;j<arr.length;j++){
      var obj = arr[j];
      if (!obj || typeof obj !== 'object'){
        rows.push(headers.map(function(){ return ''; }));
        continue;
      }
      var row = [];
      for (var h=0;h<headers.length;h++){
        var val = obj[headers[h]];
        if (val == null) val = '';
        else if (typeof val === 'object') val = JSON.stringify(val);
        row.push(String(val));
      }
      rows.push(row);
    }
    return { headers: headers, rows: rows };
  }

  function normalizeDateStr(s){
    if (!s) return '';
    s = String(s).trim();
    // Accept YYYY-MM-DD, YYYY/MM/DD, YYYY.MM.DD, or Date-parsable
    var m = s.match(/^(\d{4})[.\/-](\d{1,2})[.\/-](\d{1,2})$/);
    if (m){ var d=new Date(+m[1], +m[2]-1, +m[3]); return fmt(d); }
    var d2 = new Date(s);
    if (!isNaN(d2.getTime())) return fmt(d2);
    return '';
  }

  function openDataImport(){
    var picker = document.createElement('input'); picker.type='file'; picker.accept='.csv,text/csv,.json,application/json';
    picker.style.position='fixed'; picker.style.left='-9999px'; document.body.appendChild(picker);
    picker.addEventListener('change', function(){
      var f = picker.files && picker.files[0]; if (!f){ picker.remove(); return; }
      var reader = new FileReader();
      reader.onload = function(){
        try {
          var text = String(reader.result||'');
          var name = (f.name || '').toLowerCase();
          var isJson = (name.slice(-5) === '.json') || (f.type && f.type.indexOf('json') !== -1);
          var format = isJson ? 'json' : 'csv';
          var parsed = isJson ? parseJSONTable(text) : parseCSV(text);
          if (!parsed) return;
          showImportMapping(parsed, format);
        } finally { picker.remove(); }
      };
      reader.readAsText(f);
    });
    picker.click();
  }

  function showImportMapping(parsed, format){
    if (!parsed.headers.length){ alert('가져올 필드를 찾을 수 없습니다. 파일 내용을 확인해주세요.'); return; }
    var headers = parsed.headers;

    var wrap = document.createElement('div'); wrap.className='rm-backdrop';
    var dialog = document.createElement('div'); dialog.className='rm-modal';
    var options = headers.map(function(h){ return '<option value="'+escapeHtml(h)+'">'+escapeHtml(h)+'</option>'; }).join('');
    var mappingHint = (format === 'json') ? 'JSON 키 이름을 필드에 매핑하세요.' : 'CSV 헤더를 필드에 매핑하세요.';

    dialog.innerHTML = ''
      + '<header>데이터 가져오기</header>'
      + '<div class="rm-body">'
      +   '<div style="grid-column:1 / -1; font-size:12px; color:#4b5563;">'+mappingHint+'</div>'
      +   '<label>제목</label><select id="rm-csv-title">'+options+'</select>'
      +   '<label>레인명</label><select id="rm-csv-lane">'+options+'</select>'
      +   '<label>시작일</label><select id="rm-csv-start">'+options+'</select>'
      +   '<label>종료일</label><select id="rm-csv-end">'+options+'</select>'
      +   '<label>색상(선택)</label><select id="rm-csv-color"><option value="">(없음)</option>'+options+'</select>'
      +   '<label>모드</label>'
      +   '<div>'
      +     '<label style="margin-right:10px"><input type="radio" name="rm-csv-mode" value="append" checked/> 기존 유지 + 추가</label>'
      +     '<label><input type="radio" name="rm-csv-mode" value="overwrite"/> 완전히 덮어쓰기</label>'
      +   '</div>'
      +   '<label>날짜 범위</label>'
      +   '<div><label><input id="rm-csv-adjust" type="checkbox" checked/> 데이터 범위에 맞게 자동 조정</label></div>'
      +   '<div style="grid-column:1 / -1; margin-top:6px; font-size:12px; color:#555;">유효성 리포트를 보려면 아래 "유효성 검사"를 눌러주세요.</div>'
      +   '<div id="rm-csv-report" style="grid-column:1 / -1; max-height:220px; overflow:auto; border:1px solid #eee; border-radius:8px; padding:8px; display:none;"></div>'
      + '</div>'
      + '<footer>'
      +   '<button class="rm-btn" id="rm-csv-cancel">취소</button>'
      +   '<button class="rm-btn" id="rm-csv-validate">유효성 검사</button>'
      +   '<button class="rm-btn" id="rm-csv-import">가져오기</button>'
      + '</footer>';

    wrap.appendChild(dialog); document.body.appendChild(wrap);

    var $title = dialog.querySelector('#rm-csv-title');
    var $lane = dialog.querySelector('#rm-csv-lane');
    var $start = dialog.querySelector('#rm-csv-start');
    var $end = dialog.querySelector('#rm-csv-end');
    var $color = dialog.querySelector('#rm-csv-color');
    var $cancel = dialog.querySelector('#rm-csv-cancel');
    var $import = dialog.querySelector('#rm-csv-import');
    var $validate = dialog.querySelector('#rm-csv-validate');
    var $adjust = dialog.querySelector('#rm-csv-adjust');
    var $report = dialog.querySelector('#rm-csv-report');

    function close(){ wrap.parentNode.removeChild(wrap); }

    $cancel.addEventListener('click', function(e){ e.stopPropagation(); close(); });
    $validate.addEventListener('click', function(e){ e.stopPropagation();
      var map = { title:$title.value, lane:$lane.value, start:$start.value, end:$end.value, color:$color.value||'' };
      var rep = validateCSV(parsed, map);
      renderCSVReport($report, rep);
    });
    $import.addEventListener('click', function(e){ e.stopPropagation();
      var map = { title:$title.value, lane:$lane.value, start:$start.value, end:$end.value, color:$color.value||'' };
      if (!map.title || !map.lane || !map.start || !map.end){ alert('제목/레인명/시작일/종료일 매핑을 지정해주세요.'); return; }
      applyCSV(parsed, map, (dialog.querySelector('input[name="rm-csv-mode"]:checked')||{}).value || 'append', $adjust.checked);
      close();
    });
  }

  function validateCSV(parsed, map){
    var idx = {}; parsed.headers.forEach(function(h,i){ idx[h]=i; });
    function cell(row, key){ var i = idx[map[key]]; return (i==null)? '' : (row[i]||''); }
    var report = { total: parsed.rows.length, valid:0, skipped:0, issues:[], lanes:{}, willCreateLanes:[] };
    var existingLaneNames = state.lanes.map(function(l){ return l.name; });
    var newLaneSet = {};
    for (var r=0;r<parsed.rows.length;r++){
      var row = parsed.rows[r];
      var line = r+2; // header is line 1
      var title = String(cell(row,'title')).trim();
      var laneName = String(cell(row,'lane')).trim();
      var s = normalizeDateStr(cell(row,'start'));
      var e = normalizeDateStr(cell(row,'end'));
      var col = map.color? String(cell(row,'color')).trim() : '';
      if (!title){ report.issues.push({ line:line, type:'error', msg:'제목 없음' }); report.skipped++; continue; }
      if (!laneName){ report.issues.push({ line:line, type:'error', msg:'레인명 없음' }); report.skipped++; continue; }
      if (!s){ report.issues.push({ line:line, type:'error', msg:'시작일 형식 오류' }); report.skipped++; continue; }
      if (!e){ report.issues.push({ line:line, type:'error', msg:'종료일 형식 오류' }); report.skipped++; continue; }
      if (e < s){ report.issues.push({ line:line, type:'warn', msg:'종료 < 시작 (자동 교정됨)' }); var tmp=s; s=e; e=tmp; }
      if (col){ if (!/^#?[0-9a-fA-F]{6}$/.test(col)){ report.issues.push({ line:line, type:'warn', msg:'색상 형식 비지원: '+col }); } }
      report.valid++;
      report.lanes[laneName] = (report.lanes[laneName]||0) + 1;
      if (existingLaneNames.indexOf(laneName)===-1){ newLaneSet[laneName]=true; }
    }
    report.willCreateLanes = Object.keys(newLaneSet);
    return report;
  }

  function renderCSVReport(container, rep){
    if (!container) return; container.style.display='block';
    var parts = [];
    parts.push('<div style="margin-bottom:6px;">총 '+rep.total+'행 · 유효 '+rep.valid+' · 건너뜀 '+rep.skipped+'</div>');
    var laneLines = Object.keys(rep.lanes).map(function(name){ return escapeHtml(name)+' ('+rep.lanes[name]+')'; });
    parts.push('<div style="margin-bottom:6px;">레인별 건수: '+(laneLines.length? laneLines.join(', ') : '없음')+'</div>');
    if (rep.willCreateLanes.length){ parts.push('<div style="margin-bottom:6px;">새로 생성될 레인: '+rep.willCreateLanes.map(escapeHtml).join(', ')+'</div>'); }
    if (rep.issues.length){
      parts.push('<div style="font-weight:600; margin-top:4px;">이슈 ('+rep.issues.length+'건)</div>');
      parts.push('<ul style="margin:4px 0 0 16px;">');
      for (var i=0;i<Math.min(50, rep.issues.length);i++){
        var it = rep.issues[i];
        var color = (it.type==='error')? '#b91c1c' : '#92400e';
        parts.push('<li style="color:'+color+'">Row '+it.line+': '+escapeHtml(it.msg)+'</li>');
      }
      if (rep.issues.length>50){ parts.push('<li>... '+(rep.issues.length-50)+' 더 있음</li>'); }
      parts.push('</ul>');
    } else {
      parts.push('<div>문제 없음</div>');
    }
    container.innerHTML = parts.join('');
  }

  function applyCSV(parsed, map, mode, autoAdjust){
    var idx = {};
    parsed.headers.forEach(function(h,i){ idx[h]=i; });
    var rows = parsed.rows;

    var newLanesByName = {}; var newLanes = []; var newTasks = [];
    function ensureLane(name){
      name = String(name||'').trim() || 'Lane';
      var lane = newLanesByName[name];
      if (!lane){
        var pal = ["#c7d2fe","#bbf7d0","#fde68a","#fecaca","#a7f3d0","#fbcfe8","#bae6fd","#ddd6fe"];
        var color = pal[newLanes.length % pal.length];
        lane = { id: makeId(), name: name, color: color, parentId:null, collapsed:false };
        newLanesByName[name]=lane; newLanes.push(lane);
      }
      return lane;
    }

    var bad = 0;
    for (var r=0; r<rows.length; r++){
      var row = rows[r];
      var title = (row[idx[map.title]]||'').trim();
      var laneName = (row[idx[map.lane]]||'').trim();
      var s = normalizeDateStr(row[idx[map.start]]||'');
      var e = normalizeDateStr(row[idx[map.end]]||'');
      var col = map.color? String(row[idx[map.color]]||'').trim() : '';
      if (!title || !laneName || !s || !e){ bad++; continue; }
      if (e < s){ var t=s; s=e; e=t; }
      var lane = ensureLane(laneName);
      var tsk = { id: makeId(), laneId: lane.id, title: title, start: s, end: e, milestone:false };
      if (/^#?[0-9a-fA-F]{6}$/.test(col)){
        if (col[0] !== '#') col = '#' + col; tsk.color = col;
      }
      newTasks.push(tsk);
    }

    if (mode==='overwrite'){
      pushUndo();
      state.lanes = newLanes;
      state.tasks = newTasks;
    } else {
      pushUndo();
      // Merge lanes by name; create if missing
      var byName = {};
      state.lanes.forEach(function(l){ byName[l.name]=l; });
      newLanes.forEach(function(l){ if (!byName[l.name]){ state.lanes.push(l); byName[l.name]=l; }});
      // Re-map newTasks' laneIds to existing/created lanes by name
      newTasks.forEach(function(t){ var ln = newLanes.find(function(x){return x.id===t.laneId;}); var tgt = byName[ln.name]; t.laneId = tgt.id; state.tasks.push(t); });
    }

    if (autoAdjust && newTasks.length){
      var sMin = newTasks.reduce(function(a,t){ return a < t.start ? a : t.start; }, newTasks[0].start);
      var eMax = newTasks.reduce(function(a,t){ return a > t.end ? a : t.end; }, newTasks[0].end);
      ensureRangeCovers(sMin, eMax);
    }
    markDirty('Autosaved'); render();
    if (bad){ alert('가져오기 완료: 총 '+newTasks.length+'건, 건너뜀 '+bad+'건'); }
    else { $.status.textContent = 'Imported '+newTasks.length+' tasks'; }
  }

  /* ========= View ========= */
  el.innerHTML = ''
  + '<div class="rm-root" id="rm-root">'
  + '<div class="rm-toolbar">'
  + '  <button class="rm-btn" id="rm-add-lane" aria-label="그룹 추가">그룹 추가</button>'
  + '  <button class="rm-btn" id="rm-add-sublane" aria-label="서브 그룹 추가">서브 그룹 추가</button>'
  + '  <button class="rm-btn" id="rm-add-task" aria-label="작업 추가">작업 추가</button>'
  + '  <button class="rm-btn" id="rm-today" aria-label="오늘 날짜로 이동">오늘</button>'
  + '  <button class="rm-btn" id="rm-fit-viewport" aria-label="현재 화면 폭으로 날짜 범위 설정">화면 범위 적용</button>'
  + '  <select class="rm-select" id="rm-scale" aria-label="스케일">'
  + '    <option value="day">일간</option>'
  + '    <option value="week" selected>주간</option>'
  + '    <option value="month">월간</option>'
  + '    <option value="quarter">분기</option>'
  + '    <option value="year">연간</option>'
  + '  </select>'
  + '  <span class="rm-note">날짜 범위</span>'
  + '  <input type="date" class="rm-input" id="rm-start" aria-label="시작일"/>'
  + '  <span class="rm-muted">→</span>'
  + '  <input type="date" class="rm-input" id="rm-end" aria-label="종료일"/>'
  + '  <span class="rm-pill" id="rm-status">로드됨</span>'
  + '  <div style="flex:1"></div>'
  + '  <button class="rm-btn" id="rm-fullscreen" aria-label="전체 화면">전체 화면</button>'
  + '  <div class="rm-dropdown" id="rm-data-menu">'
  + '    <button class="rm-btn rm-dropdown__toggle" id="rm-data-menu-toggle" aria-haspopup="true" aria-expanded="false">데이터</button>'
  + '    <div class="rm-dropdown__menu" id="rm-data-menu-list" role="menu">'
  + '      <button class="rm-dropdown__item" id="rm-data-import" role="menuitem">데이터 가져오기</button>'
  + '      <button class="rm-dropdown__item" id="rm-data-export" role="menuitem">데이터 내보내기</button>'
  + '    </div>'
  + '  </div>'
  + '  <button class="rm-btn" id="rm-save" aria-label="페이지에 저장하기">페이지에 저장하기</button>'
  + '</div>'
  + '<div class="rm-container" id="rm-container">'
  + '  <div class="rm-header">'
  + '    <div class="rm-left">그룹</div>'
  + '    <div class="rm-header-resizer" aria-hidden="true"></div>'
  + '    <div class="rm-scale">'
  + '      <div class="rm-weekend-head" id="rm-weekend-head"></div>'
  + '      <div class="rm-ticks" id="rm-ticks"></div>'
  + '      <div class="rm-today-head" id="rm-today-head"></div>'
  + '    </div>'
  + '  </div>'
  + '  <div class="rm-grid" id="rm-grid">'
  + '    <div class="rm-laneswrap"><div class="rm-lanes" id="rm-lanes"></div></div>'
  + '    <div class="rm-resizer" id="rm-lane-resizer" role="separator" aria-orientation="vertical" aria-label="레인 열 폭 조절"></div>'
  + '    <div class="rm-canvaswrap" id="rm-canvaswrap"><div class="rm-canvas" id="rm-canvas"></div></div>'
  + '  </div>'
  + '</div>'
  + '</div>';

  var $ = {
    addLane: byId('rm-add-lane'),
    addSubLane: byId('rm-add-sublane'),
    addTask: byId('rm-add-task'),
    todayBtn: byId('rm-today'),
    scale: byId('rm-scale'),
    start: byId('rm-start'),
    end: byId('rm-end'),
    save: byId('rm-save'),
    dataMenu: byId('rm-data-menu'),
    dataMenuToggle: byId('rm-data-menu-toggle'),
    dataMenuList: byId('rm-data-menu-list'),
    importBtn: byId('rm-data-import'),
    exportBtn: byId('rm-data-export'),
    fullscreen: byId('rm-fullscreen'),
    root: byId('rm-root'),
    status: byId('rm-status'),
    lanes: byId('rm-lanes'),
    canvas: byId('rm-canvas'),
    canvasWrap: byId('rm-canvaswrap'),
    ticks: byId('rm-ticks'),
    todayHead: byId('rm-today-head'),
    container: byId('rm-container'),
    weekendHead: byId('rm-weekend-head'),
    resizer: byId('rm-lane-resizer'),
    grid: byId('rm-grid')
  };

  function isDataMenuOpen(){ return !!($.dataMenu && $.dataMenu.classList.contains('open')); }
  function setDataMenuOpen(open){
    if (!$.dataMenu) return;
    if (open){
      $.dataMenu.classList.add('open');
      if ($.dataMenuToggle) $.dataMenuToggle.setAttribute('aria-expanded', 'true');
      document.addEventListener('mousedown', handleDataMenuOutside, true);
      document.addEventListener('keydown', handleDataMenuKeydown, true);
    } else {
      $.dataMenu.classList.remove('open');
      if ($.dataMenuToggle) $.dataMenuToggle.setAttribute('aria-expanded', 'false');
      document.removeEventListener('mousedown', handleDataMenuOutside, true);
      document.removeEventListener('keydown', handleDataMenuKeydown, true);
    }
  }
  function toggleDataMenu(){ setDataMenuOpen(!isDataMenuOpen()); }
  function closeDataMenu(){ setDataMenuOpen(false); }
  function handleDataMenuOutside(ev){ if (!$.dataMenu || $.dataMenu.contains(ev.target)) return; closeDataMenu(); }
  function handleDataMenuKeydown(ev){ if (ev.key === 'Escape') closeDataMenu(); }

  /* ========= Timeline helpers ========= */
  function dateSpanDays(a,b){ return Math.round((new Date(b)-new Date(a))/(24*3600*1000)); }
  function getTimeline(){
    var pxPerDay = (state.scale==='day')?40
                 : (state.scale==='week')?20
                 : (state.scale==='month')?6
                 : (state.scale==='quarter')?3
                 : (state.scale==='year')?0.8
                 : 6;
    var stepDays = (state.scale==='week' || state.scale==='quarter' || state.scale==='year')?7
                 : (state.scale==='month')?30
                 : 1; // month uses custom snapping/ticks
    var rangeDays = Math.max(0, dateSpanDays(state.start, state.end));
    var totalWidth = Math.max(800, rangeDays * pxPerDay);
    var dateToX = function(d){ return Math.round(dateSpanDays(state.start, d) * pxPerDay); };
    var xToDate = function(x){ return fmt(addDays(new Date(state.start), Math.round(x / pxPerDay))); };

    // Month helpers aligned to real calendar months
    function monthStart(d){ return new Date(d.getFullYear(), d.getMonth(), 1); }
    function getMonthStarts(sStr, eStr){
      var s = monthStart(new Date(sStr));
      var e = new Date(eStr);
      var arr = [];
      var cur = new Date(s.getFullYear(), s.getMonth(), 1);
      while (cur <= e){ arr.push(new Date(cur)); cur = new Date(cur.getFullYear(), cur.getMonth()+1, 1); }
      return arr;
    }
    var monthStarts = getMonthStarts(state.start, state.end);
    var monthStartsStr = monthStarts.map(function(d){ return fmt(d); });
    var monthXs = monthStarts.map(function(d){ return dateToX(fmt(d)); });
    function nearestMonthIndex(x){
      if (!monthXs.length) return 0;
      var bestIdx = 0, bestDist = Math.abs(x - monthXs[0]);
      for (var i=1;i<monthXs.length;i++){ var dist=Math.abs(x-monthXs[i]); if (dist<bestDist){ bestDist=dist; bestIdx=i; } }
      return bestIdx;
    }
    function nearestMonthPx(x){ return monthXs[nearestMonthIndex(x)] || 0; }
    function monthPxAt(i){ if (i<0) i=0; if (i>=monthXs.length) i=monthXs.length-1; return monthXs[i]; }
    function monthIndexOfDateStr(str){ for (var i=0;i<monthStartsStr.length;i++){ if (monthStartsStr[i]===str) return i; } return -1; }
    function monthDateStrAt(i){ if (i<0) i=0; if (i>=monthStartsStr.length) i=monthStartsStr.length-1; return monthStartsStr[i]; }

    // Quarter helpers
    function getQuarterStarts(sStr, eStr){
      var s = startOfQuarter(new Date(sStr));
      var e = new Date(eStr);
      var arr = [];
      var cur = startOfQuarter(s);
      while (cur <= e){ arr.push(new Date(cur)); cur = new Date(cur.getFullYear(), cur.getMonth()+3, 1); }
      return arr;
    }
    var qStarts = getQuarterStarts(state.start, state.end);
    var qStartsStr = qStarts.map(function(d){ return fmt(d); });
    var qXs = qStarts.map(function(d){ return dateToX(fmt(d)); });

    // Year helpers
    function getYearStarts(sStr, eStr){
      var s = startOfYear(new Date(sStr));
      var e = new Date(eStr);
      var arr = [];
      var cur = startOfYear(s);
      while (cur <= e){ arr.push(new Date(cur)); cur = new Date(cur.getFullYear()+1, 0, 1); }
      return arr;
    }
    var yStarts = getYearStarts(state.start, state.end);
    var yStartsStr = yStarts.map(function(d){ return fmt(d); });
    var yXs = yStarts.map(function(d){ return dateToX(fmt(d)); });

    return {
      stepDays:stepDays, pxPerDay:pxPerDay, stepPx:stepDays*pxPerDay, rangeDays:rangeDays, totalWidth:totalWidth,
      dateToX:dateToX, xToDate:xToDate,
      monthStarts:monthStartsStr, monthXs:monthXs,
      nearestMonthPx:nearestMonthPx, nearestMonthIndex:nearestMonthIndex,
      monthPxAt:monthPxAt, monthIndexOfDateStr:monthIndexOfDateStr, monthDateStrAt:monthDateStrAt,
      quarterStarts:qStartsStr, quarterXs:qXs,
      yearStarts:yStartsStr, yearXs:yXs
    };
  }
  function isoWeek(d){
    var date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    var dayNum = (date.getUTCDay() + 6) % 7;
    date.setUTCDate(date.getUTCDate() - dayNum + 3);
    var firstThursday = new Date(Date.UTC(date.getUTCFullYear(),0,4));
    var diff = (date - firstThursday) / 86400000;
    return 1 + Math.floor(diff / 7);
  }
  function buildTicks(tl){
    $.ticks.innerHTML = '';
    $.ticks.style.width = tl.totalWidth + 'px';
    var start = new Date(state.start);
    var frag = document.createDocumentFragment();
    var step = 1, labelFmt = function(d){ return fmt(d).slice(5,10); };
    if (state.scale==='week'){ step=7; labelFmt=function(d){ return 'W'+isoWeek(d)+'\n'+fmt(d).slice(5,10); }; }
    if (state.scale==='month'){
      for (var m=0; m<tl.monthStarts.length; m++){
        var md = new Date(tl.monthStarts[m]);
        var divM = document.createElement('div');
        divM.className = 'rm-tick';
        divM.style.left = tl.monthXs[m] + 'px';
        divM.textContent = md.getFullYear()+'-'+('0'+(md.getMonth()+1)).slice(-2);
        frag.appendChild(divM);
      }
      $.ticks.appendChild(frag);
      return;
    }
    if (state.scale==='quarter'){
      for (var q=0; q<tl.quarterStarts.length; q++){
        var qd = new Date(tl.quarterStarts[q]);
        var qLabel = qd.getFullYear() + '-Q' + (Math.floor(qd.getMonth()/3) + 1);
        var divQ = document.createElement('div');
        divQ.className = 'rm-tick';
        divQ.style.left = tl.quarterXs[q] + 'px';
        divQ.textContent = qLabel;
        frag.appendChild(divQ);
      }
      $.ticks.appendChild(frag);
      return;
    }
    if (state.scale==='year'){
      for (var y=0; y<tl.yearStarts.length; y++){
        var yd = new Date(tl.yearStarts[y]);
        var divY = document.createElement('div');
        divY.className = 'rm-tick';
        divY.style.left = tl.yearXs[y] + 'px';
        divY.textContent = String(yd.getFullYear());
        frag.appendChild(divY);
      }
      $.ticks.appendChild(frag);
      return;
    }
    for (var i=0;i<=tl.rangeDays;i+=step){
      var d = addDays(start,i);
      var div = document.createElement('div');
      div.className = 'rm-tick';
      div.style.left = (Math.round(i*tl.pxPerDay))+'px';
      div.textContent = labelFmt(d);
      frag.appendChild(div);
    }
    $.ticks.appendChild(frag);
  }

  /* ========= Weekends ========= */
  function buildWeekendBands(targetEl, height, totalW, tl){
    // Use a repeating-linear-gradient instead of per-day blocks
    targetEl.innerHTML = '';
    targetEl.style.width = totalW + 'px';
    if (height != null) targetEl.style.height = height + 'px';
    var px = tl.pxPerDay;
    var weekPx = 7 * px;
    // Pattern: Mon-Fri transparent, Sat+Sun shaded (#f3f4f6)
    targetEl.style.backgroundImage = 'repeating-linear-gradient(90deg, rgba(0,0,0,0) 0, rgba(0,0,0,0) ' + (5*px) + 'px, #f3f4f6 ' + (5*px) + 'px, #f3f4f6 ' + weekPx + 'px)';
    targetEl.style.backgroundRepeat = 'repeat-x';
    targetEl.style.backgroundSize = weekPx + 'px 100%';
    // Align cycle start to Monday regardless of state.start's weekday
    var dow = new Date(state.start).getDay(); // 0=Sun..6=Sat
    var monOffsetDays = (dow + 6) % 7; // 0 when Monday
    targetEl.style.backgroundPosition = (-monOffsetDays * px) + 'px 0px';
  }

  /* ========= Lane tree helpers ========= */
  function buildLaneIndex(){
    var byId = {};
    for (var i=0;i<state.lanes.length;i++){ byId[state.lanes[i].id] = state.lanes[i]; }
    var children = {};
    state.lanes.forEach(function(l){
      var p = (l.parentId==null)? null : l.parentId;
      if (!children[p]) children[p] = [];
      children[p].push(l);
    });
    return { byId:byId, children:children };
  }
  function flattenLanes(){
    var tree = buildLaneIndex(), children = tree.children;
    var out = [];
    function walk(pid, depth){
      var arr = children[pid] || [];
      for (var i=0;i<arr.length;i++){
        var l = arr[i];
        var has = (children[l.id] && children[l.id].length>0);
        out.push({ lane:l, depth:depth, hasChildren:has });
        if (!l.collapsed) walk(l.id, depth+1);
      }
    }
    walk(null, 0);
    return out;
  }
  function descendantsOf(laneId){
    var tree = buildLaneIndex(), children = tree.children;
    var ids = [];
    (function dfs(pid){
      var arr = children[pid] || [];
      for (var i=0;i<arr.length;i++){ var l=arr[i]; ids.push(l.id); dfs(l.id); }
    })(laneId);
    return ids;
  }

  /* ========= Layout (Inclusive) ========= */
  var TRACK = { pad:8, gap:6, height:28 };
  var MILESTONE = { size:18 };
  function isTaskMilestone(task, lane){
    if (!task) return false;
    if (task.milestone !== undefined) return !!task.milestone;
    if (lane && lane.milestone) return true;
    return false;
  }
  function layoutLane(lane, laneTasks){
    var allTasks = laneTasks || [];
    var normal = [];
    var milestoneOnly = [];
    for (var i=0;i<allTasks.length;i++){
      var tk = allTasks[i];
      if (isTaskMilestone(tk, lane)) milestoneOnly.push(tk); else normal.push(tk);
    }

    var entries = normal
      .map(function(t){
        return { id:t.id, _s:+new Date(t.start), _e:+addDays(new Date(t.end),1) };
      })
      .sort(function(a,b){ return (a._s - b._s) || (a._e - b._e); });

    var tracks = [];
    var pos = {};
    for (var k=0;k<entries.length;k++){
      var ent = entries[k], placed=false;
      for (var j=0;j<tracks.length;j++){
        if (ent._s >= tracks[j]){ tracks[j]=ent._e; pos[ent.id]=j; placed=true; break; }
      }
      if (!placed){ tracks.push(ent._e); pos[ent.id]=tracks.length-1; }
    }

    var rowsNormal = tracks.length;
    var hasMilestone = milestoneOnly.length > 0;
    var totalRows;
    if (rowsNormal === 0){
      totalRows = hasMilestone ? 1 : 1;
    } else {
      totalRows = hasMilestone ? rowsNormal + 1 : rowsNormal;
    }
    if (totalRows <= 0) totalRows = 1;

    var rowHeight = TRACK.pad*2 + totalRows*TRACK.height + (totalRows-1)*TRACK.gap;

    var normalBaseRow = hasMilestone ? 1 : 0;
    for (var n=0; n<normal.length; n++){
      var nt = normal[n];
      if (pos[nt.id] === undefined) pos[nt.id] = normalBaseRow;
      else pos[nt.id] = pos[nt.id] + normalBaseRow;
    }
    if (hasMilestone){
      for (var m=0;m<milestoneOnly.length;m++){ pos[milestoneOnly[m].id] = 0; }
    }

    return { rows:totalRows, rowHeight:rowHeight, pos:pos };
  }

  function positionMilestoneLanes(entries, weekendLayer, tl){
    if (!entries.length) return;
    requestAnimationFrame(function(){
      var delta = 0;
      for (var i=0;i<entries.length;i++){
        delta += positionMilestonesForLane(entries[i]);
      }
      if (delta > 0){
        var newHeight = $.canvas.scrollHeight;
        weekendLayer.style.height = newHeight + 'px';
        buildWeekendBands(weekendLayer, newHeight, tl.totalWidth, tl);
      }
    });
  }

  function positionMilestonesForLane(entry){
    if (!entry || !entry.items || !entry.items.length) return 0;
    var laneEl = entry.laneEl;
    var rowEl = entry.rowEl;
    if (!laneEl || !rowEl) return 0;

    var baseHeight = entry.baseHeight || (TRACK.pad*2 + TRACK.height);
    var items = entry.items;

    for (var r=0; r<items.length; r++){
      items[r].el.style.top = items[r].baseTop + 'px';
    }

    var rowRect = rowEl.getBoundingClientRect();
    var data = [];
    var maxLabelH = 0;
    for (var i=0;i<items.length;i++){
      var el = items[i].el;
      var label = el.querySelector('.rm-milestone-label');
      if (!label) continue;
      var rect = label.getBoundingClientRect();
      var left = rect.left - rowRect.left;
      var right = rect.right - rowRect.left;
      data.push({ item:items[i], left:left, right:right, height:rect.height });
      if (rect.height > maxLabelH) maxLabelH = rect.height;
    }
    if (!data.length) return 0;

    data.sort(function(a,b){ return a.left - b.left; });

    var levelGap = Math.max(maxLabelH + 8, TRACK.height + 8);
    var levelRight = {};
    var assignments = [];
    var minOffset = 0;
    var maxOffset = 0;
    var spacing = levelGap;
    var levelCandidates = [0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10];

    for (var d=0; d<data.length; d++){
      var itemData = data[d];
      var level = 0;
      for (var idx=0; idx<levelCandidates.length; idx++){
        var candidate = levelCandidates[idx];
        var limit = levelRight[candidate];
        if (limit == null || itemData.left >= limit){
          level = candidate;
          levelRight[candidate] = itemData.right + 8;
          break;
        }
        if (idx === levelCandidates.length-1){
          level = candidate;
          levelRight[candidate] = itemData.right + 8;
          break;
        }
      }
      var offset = level * spacing;
      if (offset < minOffset) minOffset = offset;
      if (offset > maxOffset) maxOffset = offset;
      assignments.push({ item:itemData.item, offset:offset });
    }

    var extraTop = Math.max(0, -minOffset);
    var extraBottom = Math.max(0, maxOffset);
    var newHeight = baseHeight + extraTop + extraBottom;
    laneEl.style.height = newHeight + 'px';
    rowEl.style.height = newHeight + 'px';

    for (var a=0; a<assignments.length; a++){
      var info = assignments[a];
      var newTop = info.item.baseTop + info.offset + extraTop;
      info.item.el.style.top = newTop + 'px';
    }

    if (extraTop > 0){
      var others = rowEl.querySelectorAll('.rm-task:not([data-milestone="1"])');
      for (var o=0; o<others.length; o++){
        var current = parseFloat(others[o].style.top) || 0;
        others[o].style.top = (current + extraTop) + 'px';
      }
    }

    return extraTop + extraBottom;
  }

  /* ========= Rollup (Inclusive) ========= */
  function computeRollup(parentLaneId){
    var descIds = descendantsOf(parentLaneId);
    if (!descIds.length) return null;
    var ivs = state.tasks
      .filter(function(t){ return descIds.indexOf(t.laneId)>=0; })
      .map(function(t){ return { s:new Date(t.start), e:new Date(t.end) }; })
      .sort(function(a,b){ return a.s - b.s; });
    if (!ivs.length) return null;

    var busy = [];
    for (var i=0;i<ivs.length;i++){
      var s = ivs[i].s, eInc = addDays(ivs[i].e, 1);
      if (!busy.length || s >= busy[busy.length-1].e){
        busy.push({ s:s, e:eInc });
      }else if (eInc > busy[busy.length-1].e){
        busy[busy.length-1].e = eInc;
      }
    }
    var gaps = [];
    for (var j=1;j<busy.length;j++){ gaps.push({ s: busy[j-1].e, e: busy[j].s }); }
    return { busy:busy, gaps:gaps };
  }

  /* ========= Today marker & scroll sync ========= */
  function updateTodayMarkers(tl){
    var t0 = tl.dateToX(fmt(today()));
    var t1 = tl.dateToX(fmt(addDays(today(),1)));
    var tX = Math.round(t0 + (t1 - t0) / 2);
    if (tX < 0 || tX > tl.totalWidth) { $.todayHead.style.display = 'none'; }
    else { $.todayHead.style.display = 'block'; $.todayHead.style.left = tX+'px'; }
    var line = $.canvas.querySelector('#rm-today-line');
    if (!line){ line = document.createElement('div'); line.className='rm-today-line'; line.id='rm-today-line'; $.canvas.appendChild(line); }
    if (tX < 0 || tX > tl.totalWidth){ line.style.display='none'; }
    else { line.style.display='block'; line.style.left = tX+'px'; }
  }
  var syncScheduled = false;
  function requestSync(){
    if (syncScheduled) return;
    syncScheduled = true;
    requestAnimationFrame(function(){
      var x = -(($.canvasWrap.scrollLeft||0)) + 'px';
      $.ticks.style.transform = 'translateX('+x+')';
      $.weekendHead.style.transform = 'translateX('+x+')';
      $.todayHead.style.transform = 'translateX('+x+')';
      syncScheduled = false;
    });
  }
  $.canvasWrap.addEventListener('scroll', requestSync, { passive:true });

  /* ========= Tooltip ========= */
  var tipEl = null;
  var dragActive = false; // suppress default tips while dragging
  function ensureTip(){ if (!tipEl){ tipEl=document.createElement('div'); tipEl.className='rm-tip'; tipEl.style.display='none'; document.body.appendChild(tipEl); } }
  function showTip(text,x,y){
    ensureTip(); tipEl.textContent=text; tipEl.style.display='block';
    requestAnimationFrame(function(){
      var r = tipEl.getBoundingClientRect();
      var nx = Math.min(x+12, window.innerWidth - r.width - 8);
      var ny = Math.min(y+12, window.innerHeight - r.height - 8);
      tipEl.style.left = nx+'px'; tipEl.style.top = ny+'px';
    });
  }
  function hideTip(){ if (tipEl) tipEl.style.display='none'; }

  // Delegated tooltip handling to reduce per-task listeners
  (function setupTooltipDelegation(){
    var lastId = null;
    $.canvas.addEventListener('pointermove', function(e){
      if (dragActive) return; // suppressed while dragging
      var t = e.target.closest && e.target.closest('.rm-task');
      if (!t){ lastId=null; hideTip(); return; }
      var id = t.getAttribute('data-id');
      if (!id){ hideTip(); return; }
      var task = state.tasks.find(function(x){ return x.id===id; });
      if (!task){ hideTip(); return; }
      var lane = state.lanes.find(function(l){ return l.id === task.laneId; });
      var text = isTaskMilestone(task, lane)
        ? (task.title + ' : ' + task.end)
        : (task.title + ' : ' + task.start + ' ~ ' + task.end);
      if (lastId !== id){
        lastId = id;
      }
      showTip(text, e.clientX, e.clientY);
    }, { passive:true });
    $.canvas.addEventListener('pointerleave', function(){ lastId=null; hideTip(); }, { passive:true });
    $.canvas.addEventListener('pointerdown', function(e){ if (e.target.closest && e.target.closest('.rm-task')) hideTip(); }, { passive:true });
  })();

  /* ========= Render ========= */
  function computeLaneColWidth(flattened){
    var baseNeed=224, indentPerDepth=16, maxDepth=0;
    for (var i=0;i<flattened.length;i++) if (flattened[i].depth>maxDepth) maxDepth=flattened[i].depth;
    return Math.max(220, baseNeed + maxDepth*indentPerDepth);
  }

  function render(){
    var tl = getTimeline();

    $.scale.value = state.scale;
    $.start.value = state.start;
    $.end.value = state.end;
    buildTicks(tl);

    buildWeekendBands($.weekendHead, null, tl.totalWidth, tl);

    $.lanes.innerHTML = '';
    $.canvas.innerHTML = '';
    var lanesFrag = document.createDocumentFragment();
    var rowsFrag = document.createDocumentFragment();

    // Build lane -> tasks index once per render
    var tasksByLane = {};
    for (var ti=0; ti<state.tasks.length; ti++){
      var tt = state.tasks[ti];
      if (!tasksByLane[tt.laneId]) tasksByLane[tt.laneId] = [];
      tasksByLane[tt.laneId].push(tt);
    }

    var flattened = flattenLanes();
    var autoLaneWidth = computeLaneColWidth(flattened);
    var manualWidth = (typeof state.laneWidth === 'number' && !isNaN(state.laneWidth)) ? state.laneWidth : null;
    var laneColWidth = manualWidth != null ? Math.max(autoLaneWidth, manualWidth) : autoLaneWidth;
    if (laneColWidth < LANE_MIN_WIDTH) laneColWidth = LANE_MIN_WIDTH;
    var containerCap = laneMaxWidthFromContainer();
    if (laneColWidth > containerCap) laneColWidth = containerCap;
    if (laneColWidth > LANE_MAX_WIDTH) laneColWidth = LANE_MAX_WIDTH;
    if (manualWidth != null && laneColWidth !== manualWidth) state.laneWidth = laneColWidth;
    $.container.style.setProperty('--laneColWidth', laneColWidth + 'px');
    if ($.resizer){
      $.resizer.setAttribute('aria-valuenow', String(Math.round(laneColWidth)));
    }

    var totalCanvasH = 0;
    var milestoneLanes = [];

    flattened.forEach(function(item){
      var lane=item.lane, depth=item.depth, hasChildren=item.hasChildren;
      var laneTasks = tasksByLane[lane.id] || [];
      var layout = layoutLane(lane, laneTasks);
      var laneMeta = null;
      totalCanvasH += layout.rowHeight;
      var L = document.createElement('div');
      L.className = 'rm-lane' + ((selectedLaneId===lane.id)?' sel':'');
      L.setAttribute('data-lane', lane.id);
      L.style.height = layout.rowHeight+'px';
      L.innerHTML = ''
        + '<span class="rm-treepad" style="margin-left:'+(depth*16)+'px"></span>'
        + (hasChildren
           ? '<button class="rm-expander" data-expander="'+lane.id+'" title="'+(lane.collapsed?'펼치기 (++)':'접기 (--)')+'" aria-label="'+(lane.collapsed?'펼치기':'접기')+'">'+(lane.collapsed?'▸':'▾')+'</button>'
           : '')
        + '<span class="rm-drag" title="드래그로 순서 변경" aria-label="드래그로 순서 변경" role="button">↕</span>'
        + '<div class="rm-color" style="background:'+lane.color+'" role="button" aria-label="색상 선택"></div>'
        + '<input value="'+escapeHtml(lane.name)+'" data-lane-name="'+lane.id+'" aria-label="그룹 이름" />'
        + '<button class="rm-btn rm-del-lane" data-del-lane="'+lane.id+'" title="Delete lane" aria-label="그룹 삭제">✕</button>';
      lanesFrag.appendChild(L);

      var R = document.createElement('div');
      R.className = 'rm-row' + ((selectedLaneId===lane.id)?' sel':'');
      R.setAttribute('data-lane', lane.id);
      R.style.minWidth = tl.totalWidth + 'px';
      R.style.height = layout.rowHeight+'px';
      rowsFrag.appendChild(R);

      R.addEventListener('click', function(e){
        if (e.target.closest && (e.target.closest('.rm-task') || e.target.closest('.rm-handle'))) return;
        selectLaneNoRender(lane.id);
        selectTaskNoRender(null);
      });

      laneTasks.forEach(function(task){
        var trackIndex = (layout.pos[task.id]||0);
        var top = TRACK.pad + trackIndex*(TRACK.height + TRACK.gap);
        var isMilestoneTask = isTaskMilestone(task, lane);
        var color = task.color || lane.color || '#e5e7eb';
        var t = document.createElement('div');
        var selCls = (selectedTaskIds.indexOf(task.id) >= 0) ? ' sel' : '';
        t.setAttribute('data-id', task.id);
        t.setAttribute('role','button');
        t.setAttribute('tabindex','0');
        var ariaLabel = isMilestoneTask
          ? (task.title+' '+task.end)
          : (task.title+' '+task.start+' ~ '+task.end);
        t.setAttribute('aria-label', escapeHtml(ariaLabel));

        if (isMilestoneTask){
          var endLeft = tl.dateToX(task.end);
          t.className = 'rm-task rm-task--milestone' + selCls;
          t.style.left = endLeft+'px';
          t.style.width = MILESTONE.size+'px';
          t.style.top = top+'px';
          t.style.height = TRACK.height+'px';
          t.setAttribute('data-milestone','1');
          t.innerHTML = ''
            + '<div class="rm-milestone-shape" style="background:'+color+'"></div>'
            + '<div class="rm-milestone-label" title="'+escapeHtml(task.title)+'">'
            +   '<span class="rm-milestone-title">'+escapeHtml(task.title)+'</span>'
            +   '<span class="rm-milestone-date">'+task.end+'</span>'
            + '</div>';
          if (!laneMeta){
            laneMeta = { laneEl:L, rowEl:R, baseHeight:layout.rowHeight, items:[] };
            milestoneLanes.push(laneMeta);
          }
          laneMeta.items.push({ el:t, baseTop:top });
        } else {
          var left = tl.dateToX(task.start);
          var rightInc = tl.dateToX(fmt(addDays(new Date(task.end),1))); // end+1
          var dataWidth = Math.max(0, rightInc-left);
          var visWidth  = Math.max(16, dataWidth);
          t.className = 'rm-task' + selCls;
          t.style.left = left+'px';
          t.style.width = visWidth+'px';
          t.style.top = top+'px';
          t.style.height = TRACK.height+'px';
          t.style.background = color;
          t.innerHTML = '<div class="rm-handle left" data-side="left"></div><div class="rm-label" title="'+escapeHtml(task.title)+'">'+escapeHtml(task.title)+'</div><div class="rm-handle right" data-side="right"></div>';
        }

        // Tooltip is handled via delegated event listeners on the canvas

        t.addEventListener('click', function(e){
          e.stopPropagation();
          selectLaneNoRender(lane.id);
          if (e.shiftKey){
            selectTaskNoRender(task.id, { append:true, toggle:true });
          } else {
            selectTaskNoRender(task.id);
          }
        });

        makeDraggable(t, R, tl);
        R.appendChild(t);
      });

      var roll = computeRollup(lane.id);
      if (roll){
        var bandTop = layout.rowHeight - 8;
        roll.busy.forEach(function(iv){
          var left = tl.dateToX(fmt(iv.s));
          var rightInc = tl.dateToX(fmt(iv.e));
          var width = Math.max(2, rightInc-left);
          var d = document.createElement('div');
          d.className = 'rm-roll busy';
          d.style.left = left+'px'; d.style.top = bandTop+'px'; d.style.width = width+'px';
          d.style.background = lane.color || '#93c5fd';
          R.appendChild(d);
        });
        roll.gaps.forEach(function(iv){
          var left = tl.dateToX(fmt(iv.s));
          var right = tl.dateToX(fmt(iv.e));
          var width = Math.max(2, right-left);
          var g = document.createElement('div');
          g.className = 'rm-roll gap';
          g.style.left = left+'px'; g.style.top = bandTop+'px'; g.style.width = width+'px';
          R.appendChild(g);
        });
      }
    });

    $.lanes.appendChild(lanesFrag);
    $.canvas.appendChild(rowsFrag);

    var weekendLayer = document.createElement('div');
    weekendLayer.className = 'rm-weekends-layer';
    weekendLayer.style.height = totalCanvasH + 'px';
    $.canvas.appendChild(weekendLayer);
    buildWeekendBands(weekendLayer, totalCanvasH, tl.totalWidth, tl);
    positionMilestoneLanes(milestoneLanes, weekendLayer, tl);

    updateTodayMarkers(tl);
    syncTaskSelectionUI();
    requestSync();
  }

  function syncTaskSelectionUI(){
    Array.prototype.forEach.call(document.querySelectorAll('.rm-task.sel'), function(x){ x.classList.remove('sel'); });
    if (!selectedTaskIds || !selectedTaskIds.length) return;
    selectedTaskIds.forEach(function(selId){
      var el = $.canvas.querySelector('.rm-task[data-id="'+selId+'"]');
      if (el) el.classList.add('sel');
    });
  }

  function selectTaskNoRender(id, opts){
    opts = opts || {};

    if (id == null && !opts.append){
      selectedTaskId = null;
      selectedTaskIds = [];
      syncTaskSelectionUI();
      return;
    }

    if (id == null){
      return;
    }

    if (opts.append){
      var exists = selectedTaskIds.indexOf(id) >= 0;
      if (opts.toggle && exists){
        selectedTaskIds = selectedTaskIds.filter(function(x){ return x !== id; });
        if (selectedTaskId === id){
          selectedTaskId = selectedTaskIds.length ? selectedTaskIds[selectedTaskIds.length - 1] : null;
        }
      } else {
        if (!exists){ selectedTaskIds = selectedTaskIds.concat(id); }
        selectedTaskId = id;
      }
    } else {
      selectedTaskId = id;
      selectedTaskIds = [id];
    }

    if (!selectedTaskIds.length){
      selectedTaskId = null;
    }

    syncTaskSelectionUI();
  }

  function clearTaskSelection(){
    selectedTaskId = null;
    selectedTaskIds = [];
    syncTaskSelectionUI();
  }

  function ensurePrimaryTaskSelection(id){
    if (!id) return;
    var idx = selectedTaskIds.indexOf(id);
    if (idx === -1) return;
    if (idx === selectedTaskIds.length - 1){
      selectedTaskId = id;
      return;
    }
    selectedTaskIds.splice(idx, 1);
    selectedTaskIds.push(id);
    selectedTaskId = id;
    syncTaskSelectionUI();
  }

  function selectLaneNoRender(id){
    selectedLaneId = id || null;
    Array.prototype.forEach.call(document.querySelectorAll('.rm-lane.sel,.rm-row.sel'), function(x){ x.classList.remove('sel'); });
    if (!id) return;
    var laneEl = $.lanes.querySelector('.rm-lane[data-lane="'+id+'"]');
    if (laneEl) laneEl.classList.add('sel');
    var rowEl = $.canvas.querySelector('.rm-row[data-lane="'+id+'"]');
    if (rowEl) rowEl.classList.add('sel');
  }

  /* ========= Interactions ========= */
  function markDirty(txt){ $.status.textContent = txt || 'Saved'; saveToLocal(); }

  $.scale.onchange = function(e){
    pushUndo();
    state.scale = e.target.value;
    if (state.scale==='week'){
      var s = ceilToMonday(new Date(state.start));
      state.start = fmt(s);
      state.end = fmt(addDays(s,35));
    } else if (state.scale==='month'){
      var m = startOfMonth(new Date(state.start));
      state.start = fmt(m);
      state.end = fmt(endOfMonth(addDays(m,60)));
    } else if (state.scale==='quarter'){
      var q = startOfQuarter(new Date(state.start));
      state.start = fmt(q);
      // show ~4 quarters (1 year)
      state.end = fmt(endOfQuarter(addDays(q, 270)));
    } else if (state.scale==='year'){
      var y0 = startOfYear(new Date(state.start));
      state.start = fmt(y0);
      // show ~2 years
      state.end = fmt(endOfYear(addDays(y0, 365)));
    }
    // If tasks exist, fit the visible range to min(start)~max(end)
    if (state.tasks && state.tasks.length){
      fitRangeToAllTasks();
    }
    markDirty('Autosaved'); render();
  };
  $.start.onchange = function(e){ pushUndo(); state.start = e.target.value; markDirty('Autosaved'); render(); };
  $.end.onchange   = function(e){ pushUndo(); state.end   = e.target.value; markDirty('Autosaved'); render(); };

  $.todayBtn.onclick = function(){ focusToday(true); };
  byId('rm-fit-viewport').onclick = function(){
    pushUndo();
    fitRangeToViewport();
    markDirty('Autosaved');
    render();
  };

  /* Fullscreen toggle */
  function isFullscreen(){
    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
  }
  function enterFullscreen(el){
    var fn = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
    if (fn) fn.call(el);
  }
  function exitFullscreen(){
    var fn = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
    if (fn) fn.call(document);
  }
  function updateFsUI(){
    if (!$.fullscreen) return;
    $.fullscreen.textContent = isFullscreen() ? '전체 화면 종료' : '전체 화면';
  }
  if ($.fullscreen){
    $.fullscreen.onclick = function(){
      if (isFullscreen()) exitFullscreen(); else enterFullscreen($.root || $.container);
    };
    document.addEventListener('fullscreenchange', updateFsUI);
    document.addEventListener('webkitfullscreenchange', updateFsUI);
    updateFsUI();
  }

  function focusToday(expandIfOut){
    var tl = getTimeline();
    var t = fmt(today());
    var inRange = (t >= state.start && t <= state.end);
    if (!inRange && expandIfOut){
      pushUndo();
      if (state.scale==='day'){
        state.start = fmt(addDays(new Date(t), -7));
        state.end   = fmt(addDays(new Date(t), 14));
      } else if (state.scale==='week'){
        var s = ceilToMonday(new Date(t));
        state.start = fmt(addDays(s, -7));
        state.end   = fmt(addDays(s, 35));
      } else {
        var m = startOfMonth(new Date(t));
        state.start = fmt(m);
        state.end = fmt(endOfMonth(addDays(m, 60)));
      }
      render();
    } else {
      var x = tl.dateToX(t);
      var target = Math.max(0, x - ($.canvasWrap.clientWidth * 0.4));
      $.canvasWrap.scrollLeft = target;
      requestSync();
    }
  }

  /* 좌측 영역: 삭제/색상/토글/포커스 */
  $.lanes.addEventListener('click', function(e){
    var del = e.target.closest && e.target.closest('[data-del-lane]');
    var exp = e.target.closest && e.target.closest('[data-expander]');
    var color = e.target.closest && e.target.closest('.rm-color');
    var laneEl = e.target.closest && e.target.closest('.rm-lane');

    if (exp){
      var id = exp.getAttribute('data-expander');
      var lane = state.lanes.find(function(l){return l.id===id;}); if (!lane) return;
      pushUndo(); lane.collapsed = !lane.collapsed; markDirty('Autosaved'); render(); return;
    }
    if (del){
      var id2 = del.getAttribute('data-del-lane');
      var hasDesc = descendantsOf(id2).length > 0;
      var msg = hasDesc ? '이 레인과 모든 하위 레인을 삭제할까요? (해당 작업의 태스크도 삭제됩니다)' : '이 레인을 삭제할까요? (해당 작업의 태스크도 삭제됩니다)';
      if (!confirm(msg)) return;
      pushUndo();
      var ids = [id2].concat(descendantsOf(id2));
      state.tasks = state.tasks.filter(function(t){ return ids.indexOf(t.laneId)===-1; });
      state.lanes = state.lanes.filter(function(l){ return ids.indexOf(l.id)===-1; });
      fitRangeToAllTasks();
      if (ids.indexOf(selectedLaneId)>=0) selectedLaneId = state.lanes[0] ? state.lanes[0].id : null;
      markDirty('Autosaved'); render(); return;
    }
    if (color){
      var L = laneEl && laneEl.getAttribute('data-lane'); if (!L) return;
      var lane = state.lanes.find(function(l){return l.id===L;}); if (!lane) return;
      var picker = document.createElement('input');
      picker.type='color'; picker.value = lane.color || '#c7d2fe';
      picker.style.position='fixed'; picker.style.left='-9999px';
      document.body.appendChild(picker);
      picker.addEventListener('input', function(ev){ lane.color = ev.target.value; color.style.background = lane.color; });
      picker.addEventListener('change', function(){ pushUndo(); markDirty('Autosaved'); render(); picker.parentNode.removeChild(picker); });
      picker.click();
      return;
    }
    if (laneEl){
      var laneId = laneEl.getAttribute('data-lane');
      selectLaneNoRender(laneId);
      selectTaskNoRender(null);
    }
  });
  $.lanes.addEventListener('input', function(e){
    var id = e.target.getAttribute('data-lane-name'); if (!id) return;
    var lane = state.lanes.find(function(l){return l.id===id;});
    if (lane){ lane.name = e.target.value; markDirty('Autosaved'); }
  });
  /* ========= Lane DnD (재정렬) ========= */
  (function setupLaneDnD(){
    var drag = null;

    function moveLaneWithinParent(laneId, parentId, beforeId){
      var ids = [laneId].concat(descendantsOf(laneId));                // 이동할 서브트리
      var remaining = state.lanes.filter(function(l){ return ids.indexOf(l.id)===-1; });

      var insertIdx;
      if (beforeId == null){
        insertIdx = remaining.length;
        for (var i=remaining.length-1;i>=0;i--){
          var p = (remaining[i].parentId==null? null : remaining[i].parentId);
          if (p === (parentId==null? null : parentId)){ insertIdx = i+1; break; }
        }
      } else {
        insertIdx = -1;
        for (var j=0;j<remaining.length;j++){ if (remaining[j].id===beforeId){ insertIdx=j; break; } }
        if (insertIdx<0) insertIdx = remaining.length;
      }
      var head = remaining.slice(0, insertIdx);
      var tail = remaining.slice(insertIdx);
      var moved = state.lanes.filter(function(l){ return ids.indexOf(l.id)>=0; });
      state.lanes = head.concat(moved, tail);
    }

    function measureSiblings(parentId, ignoreId){
      var sibIds = state.lanes.filter(function(l){ return (l.parentId==null? null : l.parentId) === (parentId==null? null : parentId); })
                              .map(function(l){ return l.id; })
                              .filter(function(id){ return id!==ignoreId; });
      var baseTop = $.lanes.getBoundingClientRect().top;
      var items = [];
      for (var i=0;i<sibIds.length;i++){
        var id = sibIds[i];
        var el = $.lanes.querySelector('.rm-lane[data-lane="'+id+'"]');
        if (!el) continue;
        var rect = el.getBoundingClientRect();
        items.push({ id:id, rect:rect });
      }
      return { items:items, baseTop:baseTop };
    }

    $.lanes.addEventListener('mousedown', function(e){
      if (e.button !== 0) return;
      var handle = e.target.closest && e.target.closest('.rm-drag');
      if (!handle) return;
      var laneEl = e.target.closest('.rm-lane');
      if (!laneEl) return;
      var laneId = laneEl.getAttribute('data-lane');
      var lane = state.lanes.find(function(l){ return l.id===laneId; });
      if (!lane) return;

      drag = { laneId:laneId, parentId:(lane.parentId==null? null : lane.parentId), line:document.createElement('div') };
      drag.line.className = 'rm-insert-line';
      $.lanes.appendChild(drag.line);

      function updateLine(clientY){
        var meas = measureSiblings(drag.parentId, drag.laneId);
        var idx = 0;
        for (var i=0;i<meas.items.length;i++){
          var r = meas.items[i].rect;
          if (clientY > r.top + r.height/2) idx = i+1; else break;
        }
        var topPx;
        if (idx >= meas.items.length){
          var last = meas.items[meas.items.length-1];
          topPx = last ? (last.rect.bottom - meas.baseTop) : 0;
        } else {
          topPx = meas.items[idx].rect.top - meas.baseTop;
        }
        drag.beforeId = (idx >= meas.items.length) ? null : meas.items[idx].id;
        drag.line.style.top = Math.max(0, topPx - 1) + 'px';
      }

      function onMove(ev){ updateLine(ev.clientY); }
      function onUp(){
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        if (drag && drag.line && drag.line.parentNode) drag.line.parentNode.removeChild(drag.line);

        pushUndo();
        moveLaneWithinParent(drag.laneId, drag.parentId, drag.beforeId);
        markDirty('Autosaved'); render();
        drag = null;
      }

      updateLine(e.clientY);
      window.addEventListener('mousemove', onMove, { passive:false });
      window.addEventListener('mouseup', onUp, { passive:true });
      e.preventDefault();
    });
  })();

  function createLane(parentLaneId, options){
    var parent = null;
    if (parentLaneId){
      parent = state.lanes.find(function(l){ return l.id===parentLaneId; });
      if (!parent) return null;
    }
    pushUndo();
    var name;
    if (options && options.name){ name = options.name; }
    else if (parent){
      var count = state.lanes.filter(function(l){ return l.parentId === parent.id; }).length;
      name = parent.name + ' / Sub ' + (count + 1);
    } else {
      name = 'Lane ' + (state.lanes.length + 1);
    }
    var lane = {
      id: makeId(),
      name: name,
      color: (options && options.color) || pickColor(),
      parentId: parent ? parent.id : null,
      collapsed: false,
      milestone: false
    };
    state.lanes.push(lane);
    selectedLaneId = lane.id;
    selectedTaskId = null;
    selectedTaskIds = [];
    markDirty('Autosaved');
    render();
    return lane;
  }

  function createTask(laneId, options){
    if (!laneId) return null;
    pushUndo();
    var start = (options && options.start) || fmt(today());
    var end = (options && options.end) || start;
    var title = (options && options.title) || 'New Task';
    var color = (options && options.color != null) ? options.color : null;
    var milestone = options && options.milestone ? true : false;
    var openEditor = options && options.openEditor;
    var owner = (options && typeof options.owner === 'string') ? options.owner.trim() : '';
    var task = {
      id: makeId(),
      laneId: laneId,
      title: title,
      start: start,
      end: end,
      color: color,
      milestone: milestone
    };
    if (owner){ task.owner = owner; }
    state.tasks.push(task);
    selectedLaneId = laneId;
    selectedTaskId = task.id;
    selectedTaskIds = [task.id];
    ensureRangeCovers(task.start, task.end);
    markDirty('Autosaved');
    render();
    if (openEditor){ setTimeout(function(){ openTaskEditor(task.id); }, 0); }
    return task;
  }

  function deleteSelectedTask(){
    if (!selectedTaskIds || selectedTaskIds.length === 0) return false;
    pushUndo();
    var removeSet = selectedTaskIds.slice();
    state.tasks = state.tasks.filter(function(x){ return removeSet.indexOf(x.id) === -1; });
    fitRangeToAllTasks();
    clearTaskSelection();
    markDirty('Autosaved');
    render();
    return true;
  }

  function copySelectedTask(){
    var targetId = selectedTaskId || (selectedTaskIds.length ? selectedTaskIds[selectedTaskIds.length - 1] : null);
    if (!targetId) return false;
    var cTask = state.tasks.find(function(x){ return x.id === targetId; });
    if (!cTask) return false;
    window.__rm_clipboard_task = JSON.parse(JSON.stringify(cTask));
    return true;
  }

  function pasteTaskIntoLane(laneId){
    if (!laneId) return false;
    var clip = window.__rm_clipboard_task;
    if (!clip) return false;
    pushUndo();
    var newTask = {
      id: makeId(),
      laneId: laneId,
      title: clip.title,
      start: clip.start,
      end: clip.end,
      color: clip.color || null,
      milestone: !!clip.milestone
    };
    if (clip.owner){ newTask.owner = clip.owner; }
    state.tasks.push(newTask);
    selectedLaneId = laneId;
    selectedTaskId = newTask.id;
    selectedTaskIds = [newTask.id];
    ensureRangeCovers(newTask.start, newTask.end);
    markDirty('Autosaved');
    render();
    return true;
  }

  /* 추가/저장 */
  if ($.dataMenuToggle){
    $.dataMenuToggle.addEventListener('click', function(ev){ ev.preventDefault(); ev.stopPropagation(); toggleDataMenu(); });
  }
  if ($.importBtn){
    $.importBtn.addEventListener('click', function(ev){ ev.preventDefault(); closeDataMenu(); openDataImport(); });
  }
  if ($.exportBtn){
    $.exportBtn.addEventListener('click', function(ev){ ev.preventDefault(); closeDataMenu(); exportStateAsFile(); });
  }
  $.addLane.onclick = function(){ createLane(null); };
  $.addSubLane.onclick = function(){
    if (!selectedLaneId){ alert('먼저 상위 레인을 선택하세요.'); return; }
    var parent = state.lanes.find(function(l){return l.id===selectedLaneId;}); if (!parent){ alert('유효하지 않은 상위 레인입니다.'); return; }
    createLane(parent.id);
  };
  $.addTask.onclick = function(){
    if (!selectedLaneId){ alert('먼저 레인을 선택하세요.'); return; }
    createTask(selectedLaneId, { end: fmt(addDays(today(), 5)), openEditor: true });
  };

  /* ========= Context Menu ========= */
  var contextMenuEl = null;
  var contextMenuState = null;

  function closeContextMenu(){
    if (contextMenuEl && contextMenuEl.parentNode){ contextMenuEl.parentNode.removeChild(contextMenuEl); }
    contextMenuEl = null;
    contextMenuState = null;
    document.removeEventListener('mousedown', handleMenuOutside, true);
    document.removeEventListener('scroll', handleMenuScroll, true);
    document.removeEventListener('keydown', handleMenuKeyDown, true);
    document.removeEventListener('contextmenu', handleMenuContext, true);
    window.removeEventListener('blur', handleMenuWindowClose);
    window.removeEventListener('resize', handleMenuWindowClose);
  }

  function handleMenuOutside(ev){ if (contextMenuEl && !contextMenuEl.contains(ev.target)) closeContextMenu(); }
  function handleMenuScroll(){ closeContextMenu(); }
  function handleMenuKeyDown(ev){ if (ev.key === 'Escape') closeContextMenu(); }
  function handleMenuContext(ev){ if (contextMenuEl && !contextMenuEl.contains(ev.target)) closeContextMenu(); }
  function handleMenuWindowClose(){ closeContextMenu(); }

  function openContextMenu(x, y, laneId, taskId){
    closeContextMenu();
    contextMenuState = { laneId: laneId || null, taskId: taskId || null };
    var menu = document.createElement('div');
    menu.className = 'rm-context-menu';
    contextMenuEl = menu;

    var hasLane = !!laneId;
    var hasTask = !!taskId;
    var hasClipboard = !!window.__rm_clipboard_task;
    var actions = [
      { action:'task-add', label:'태스크 추가', enabled:hasLane },
      { action:'task-edit', label:'태스크 편집', enabled:hasTask },
      { action:'task-delete', label:'태스크 삭제', enabled:hasTask },
      { action:'task-copy', label:'태스크 복사', enabled:hasTask },
      { action:'task-paste', label:'태스크 붙여넣기', enabled:hasLane && hasClipboard },
      { separator:true },
      { action:'lane-add', label:'레인 추가', enabled:true }
    ];

    actions.forEach(function(item){
      if (item.separator){
        var sep = document.createElement('div');
        sep.className = 'rm-context-sep';
        menu.appendChild(sep);
        return;
      }
      var btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = item.label;
      btn.setAttribute('data-action', item.action);
      if (!item.enabled) btn.disabled = true;
      menu.appendChild(btn);
    });

    menu.addEventListener('click', function(ev){
      var btn = ev.target.closest && ev.target.closest('button');
      if (!btn || btn.disabled) return;
      ev.preventDefault();
      var action = btn.getAttribute('data-action');
      var lane = contextMenuState ? contextMenuState.laneId : null;
      var task = contextMenuState ? contextMenuState.taskId : null;
      closeContextMenu();
      if (action === 'task-add' && lane){
        createTask(lane, { end: fmt(addDays(today(),0)), openEditor: true });
      } else if (action === 'task-edit' && task){
        openTaskEditor(task);
      } else if (action === 'task-delete'){ 
        deleteSelectedTask();
      } else if (action === 'task-copy'){ 
        copySelectedTask();
      } else if (action === 'task-paste' && lane){
        pasteTaskIntoLane(lane);
      } else if (action === 'lane-add'){
        createLane(null);
      }
    });

    document.body.appendChild(menu);
    menu.style.left = '0px';
    menu.style.top = '0px';
    var rect = menu.getBoundingClientRect();
    var left = Math.min(x, window.innerWidth - rect.width - 8);
    var top = Math.min(y, window.innerHeight - rect.height - 8);
    if (left < 8) left = 8;
    if (top < 8) top = 8;
    menu.style.left = left + 'px';
    menu.style.top = top + 'px';

    setTimeout(function(){
      document.addEventListener('mousedown', handleMenuOutside, true);
      document.addEventListener('scroll', handleMenuScroll, true);
      document.addEventListener('keydown', handleMenuKeyDown, true);
      document.addEventListener('contextmenu', handleMenuContext, true);
      window.addEventListener('blur', handleMenuWindowClose);
      window.addEventListener('resize', handleMenuWindowClose);
    }, 0);
  }

  $.canvas.addEventListener('contextmenu', function(e){
    if (!e.target) return;
    var taskEl = e.target.closest && e.target.closest('.rm-task');
    var rowEl = e.target.closest && e.target.closest('.rm-row');
    var laneId = rowEl ? rowEl.getAttribute('data-lane') : (selectedLaneId || null);
    if (taskEl){
      var taskId = taskEl.getAttribute('data-id');
      if (laneId) selectLaneNoRender(laneId);
      if (taskId) selectTaskNoRender(taskId);
    } else if (laneId){
      selectLaneNoRender(laneId);
      selectTaskNoRender(null);
    }
    e.preventDefault();
    openContextMenu(e.clientX, e.clientY, laneId, selectedTaskId);
  });

  /* ========= Lane Width Resize ========= */
  function preventSelection(ev){ ev.preventDefault(); }
  function currentLaneWidth(){
    var val = window.getComputedStyle($.container).getPropertyValue('--laneColWidth');
    var num = parseFloat(val);
    if (isNaN(num)){ num = (typeof state.laneWidth === 'number') ? state.laneWidth : LANE_MIN_WIDTH; }
    if (!isFinite(num)) num = LANE_MIN_WIDTH;
    return num;
  }
  function laneMaxWidthFromContainer(){
    var base = LANE_MAX_WIDTH;
    var gridWidth = $.grid ? $.grid.clientWidth : 0;
    var containerWidth = gridWidth || $.container.clientWidth || $.container.offsetWidth;
    if (containerWidth){
      var allow = containerWidth - 160;
      if (!isNaN(allow) && allow > 0){ base = Math.min(base, allow); }
    }
    if (base < LANE_MIN_WIDTH) base = LANE_MIN_WIDTH;
    return base;
  }
  function updateResizeGuide(width){
    if (!laneResizeInfo) return;
    var rect = $.container.getBoundingClientRect();
    laneResizeInfo.containerTop = rect.top;
    laneResizeInfo.containerHeight = rect.height;
    if (laneResizeInfo.guide){
      laneResizeInfo.guide.style.left = (rect.left + width) + 'px';
      laneResizeInfo.guide.style.top = rect.top + 'px';
      laneResizeInfo.guide.style.height = rect.height + 'px';
    }
  }
  function cleanupLaneResize(){
    document.removeEventListener('mousemove', onLaneResizerMove, true);
    document.removeEventListener('mouseup', onLaneResizerUp, true);
    document.removeEventListener('selectstart', preventSelection, true);
    document.body.style.cursor = '';
    if ($.resizer) $.resizer.classList.remove('dragging');
    if (laneResizeInfo && laneResizeInfo.guide && laneResizeInfo.guide.parentNode){ laneResizeInfo.guide.parentNode.removeChild(laneResizeInfo.guide); }
    laneResizeInfo = null;
  }
  function onLaneResizerMove(ev){
    if (!laneResizeInfo) return;
    ev.preventDefault();
    var delta = ev.clientX - laneResizeInfo.startX;
    var width = laneResizeInfo.startWidth + delta;
    if (width < laneResizeInfo.min) width = laneResizeInfo.min;
    if (width > laneResizeInfo.max) width = laneResizeInfo.max;
    laneResizeInfo.width = width;
    updateResizeGuide(width);
  }
  function onLaneResizerUp(ev){
    if (!laneResizeInfo) return;
    ev.preventDefault();
    var width = laneResizeInfo.width != null ? laneResizeInfo.width : laneResizeInfo.startWidth;
    cleanupLaneResize();
    width = Math.round(width);
    if (width < LANE_MIN_WIDTH) width = LANE_MIN_WIDTH;
    var maxAllowed = laneMaxWidthFromContainer();
    if (width > maxAllowed) width = maxAllowed;
    var prev = (typeof state.laneWidth === 'number' && !isNaN(state.laneWidth)) ? state.laneWidth : null;
    if (prev !== null && Math.abs(width - prev) < 1) return;
    pushUndo();
    state.laneWidth = width;
    markDirty('Autosaved');
    render();
  }
  function onLaneResizerDown(ev){
    if (ev.button !== 0) return;
    ev.preventDefault();
    closeContextMenu();
    var current = currentLaneWidth();
    var max = laneMaxWidthFromContainer();
    laneResizeInfo = {
      startX: ev.clientX,
      startWidth: current,
      width: current,
      min: LANE_MIN_WIDTH,
      max: max,
      guide: null
    };
    if (laneResizeInfo.max < laneResizeInfo.min) laneResizeInfo.max = laneResizeInfo.min;
    if ($.resizer) $.resizer.classList.add('dragging');
    var guide = document.createElement('div');
    guide.className = 'rm-resize-guide';
    document.body.appendChild(guide);
    laneResizeInfo.guide = guide;
    document.body.style.cursor = 'col-resize';
    updateResizeGuide(current);
    document.addEventListener('mousemove', onLaneResizerMove, true);
    document.addEventListener('mouseup', onLaneResizerUp, true);
    document.addEventListener('selectstart', preventSelection, true);
  }
  if ($.resizer){
    $.resizer.setAttribute('aria-valuemin', String(LANE_MIN_WIDTH));
    $.resizer.setAttribute('aria-valuemax', String(LANE_MAX_WIDTH));
    $.resizer.addEventListener('mousedown', onLaneResizerDown);
  }

  $.save.onclick = function(){
    $.save.disabled = true; $.status.textContent = 'Saving…';
    saveToAttachment().then(function(){ $.status.textContent = 'Saved to attachment'; })
      .catch(function(e){ console.error(e); $.status.innerHTML = 'Save failed <span class="rm-danger">(open console)</span>'; alert('첨부 저장에 실패했습니다.\n권한/네트워크 상태를 확인해주세요.'); })
      .finally(function(){ $.save.disabled = false; });
  };

  function ensureRangeCovers(s, e){
    if (s == null && e == null){
      fitRangeToAllTasks();
      return;
    }
    fitRangeToAllTasks({ start: s, end: e });
  }

  // Fit current date 범위 to include all tasks (and optional extra ranges)
  function fitRangeToAllTasks(extraRange){
    var extras = [];
    if (extraRange != null){
      if (Array.isArray(extraRange)) extras = extraRange;
      else extras = [extraRange];
    }

    var ranges = [];
    if (state && Array.isArray(state.tasks)){
      state.tasks.forEach(function(t){
        if (!t) return;
        var sVal = t.start || t.end;
        var eVal = t.end || t.start;
        if (!sVal && !eVal) return;
        if (!sVal) sVal = eVal;
        if (!eVal) eVal = sVal;
        if (sVal > eVal){ var swap = sVal; sVal = eVal; eVal = swap; }
        ranges.push({ start:sVal, end:eVal });
      });
    }

    extras.forEach(function(r){
      if (!r) return;
      var sVal = r.start || r.end;
      var eVal = r.end || r.start;
      if (!sVal && !eVal) return;
      if (!sVal) sVal = eVal;
      if (!eVal) eVal = sVal;
      if (sVal > eVal){ var swap = sVal; sVal = eVal; eVal = swap; }
      ranges.push({ start:sVal, end:eVal });
    });

    if (!ranges.length) return;

    var min = ranges[0].start;
    var max = ranges[0].end;
    for (var i=1;i<ranges.length;i++){
      var r = ranges[i];
      if (r.start < min) min = r.start;
      if (r.end > max) max = r.end;
    }

    state.start = min;
    state.end = max;
  }

  // Fit current date range to the currently visible canvas viewport
  function fitRangeToViewport(){
    var tl = getTimeline();
    var leftX = $.canvasWrap.scrollLeft || 0;
    var rightX = leftX + ($.canvasWrap.clientWidth || 0);
    var s = tl.xToDate(leftX);
    var e = tl.xToDate(rightX);
    state.start = s;
    state.end = e;
  }
  function pickColor(){ var list=["#c7d2fe","#bbf7d0","#fde68a","#fecaca","#a7f3d0","#fbcfe8","#bae6fd","#ddd6fe"]; return list[state.lanes.length % list.length]; }

  /* ========= Drag & Resize (Inclusive) ========= */
  function makeDraggable(node, row, tl){
    var mode=null, startX=0, baseLeft=0, baseRight=0;
    var isMilestoneDrag=false, baseTaskStart=null, baseTaskEnd=null, baseSpanPx=0;
    var id = node.getAttribute('data-id');
    var rowsCache = function(){
      return Array.prototype.map.call($.canvas.querySelectorAll('.rm-row'), function(r){
        return { el:r, rect:r.getBoundingClientRect(), laneId:r.getAttribute('data-lane') };
      });
    };
    var lastShiftDays = 0;
    var multiMeta = null;
    var selectionIdsAtDrag = [];

    node.addEventListener('mousedown', function(e){
      if (e.button !== 0) return;
      var withinLeft = e.target.classList.contains('left');
      var withinRight = e.target.classList.contains('right');
      mode = withinLeft ? 'left' : (withinRight ? 'right' : 'move');
      startX = e.clientX;

      multiMeta = null;
      selectionIdsAtDrag = [];
      lastShiftDays = 0;

      var t = state.tasks.find(function(t){return t.id===id;});
      var lane = t ? state.lanes.find(function(l){ return l.id===t.laneId; }) : null;
      isMilestoneDrag = isTaskMilestone(t, lane);
      baseTaskStart = t ? t.start : null;
      baseTaskEnd = t ? t.end : null;
      if (isMilestoneDrag && t){
        baseLeft  = tl.dateToX(t.end);
        baseRight = baseLeft + (MILESTONE && MILESTONE.size ? MILESTONE.size : 18);
      } else if (t){
        baseLeft  = tl.dateToX(t.start);
        baseRight = tl.dateToX(fmt(addDays(new Date(t.end),1)));
      } else {
        baseLeft = baseRight = 0;
      }
      baseSpanPx = baseRight - baseLeft;

      if (lane){ selectLaneNoRender(lane.id); }
      if (e.shiftKey){
        selectTaskNoRender(id, { append:true });
      } else if (selectedTaskIds.indexOf(id) === -1){
        selectTaskNoRender(id);
      } else {
        ensurePrimaryTaskSelection(id);
      }
      selectionIdsAtDrag = selectedTaskIds.slice();

      hideTip();
      e.preventDefault();
      dragActive = true;

      pushUndo();
      var rcList = rowsCache();
      var dayPx = tl.pxPerDay || 1;
      var baseLeftDays = Math.round(baseLeft / dayPx);
      var baseRightDays = Math.round(baseRight / dayPx);
      var baseSpanDays = Math.max(1, baseRightDays - baseLeftDays);

      if (mode === 'move' && selectionIdsAtDrag.length > 1){
        multiMeta = selectionIdsAtDrag.map(function(selId){
          var selTask = state.tasks.find(function(taskItem){ return taskItem.id === selId; });
          if (!selTask) return null;
          var selLane = state.lanes.find(function(l){ return l.id === selTask.laneId; }) || null;
          var selIsMilestone = isTaskMilestone(selTask, selLane);
          var leftPxSel = selIsMilestone ? tl.dateToX(selTask.end) : tl.dateToX(selTask.start);
          var rightPxSel = selIsMilestone
            ? leftPxSel + (MILESTONE && MILESTONE.size ? MILESTONE.size : 18)
            : tl.dateToX(fmt(addDays(new Date(selTask.end), 1)));
          var nodeSel = (selId === id) ? node : $.canvas.querySelector('.rm-task[data-id="'+selId+'"]');
          if (!nodeSel) return null;
          return {
            id: selId,
            task: selTask,
            lane: selLane,
            isMilestone: selIsMilestone,
            node: nodeSel,
            baseStart: selTask.start,
            baseEnd: selTask.end,
            baseLeft: leftPxSel,
            baseRight: rightPxSel,
            baseSpanPx: rightPxSel - leftPxSel
          };
        }).filter(function(x){ return !!x; });
      } else {
        multiMeta = null;
      }

      function onMove(ev){
        if (!mode) return;
        var dx = ev.clientX - startX;
        var newLeft = baseLeft;
        var newRight = baseRight;
        var shiftDays = 0;
        if (mode === 'move'){
          shiftDays = Math.round(dx / dayPx);
          var newLeftDays = baseLeftDays + shiftDays;
          if (newLeftDays < 0) newLeftDays = 0;
          newLeft = newLeftDays * dayPx;
          if (isMilestoneDrag){
            newRight = newLeft + baseSpanPx;
          } else {
            newRight = (newLeftDays + baseSpanDays) * dayPx;
          }
        } else if (mode === 'left'){
          var leftDays = Math.round((baseLeft + dx) / dayPx);
          if (leftDays < 0) leftDays = 0;
          if (!isMilestoneDrag){
            var maxLeft = baseRightDays - 1;
            if (leftDays > maxLeft) leftDays = maxLeft;
          } else if (leftDays > baseRightDays){
            leftDays = baseRightDays;
          }
          newLeft = leftDays * dayPx;
          newRight = baseRight;
        } else if (mode === 'right'){
          var rightDays = Math.round((baseRight + dx) / dayPx);
          if (!isMilestoneDrag){
            var minRight = baseLeftDays + 1;
            if (rightDays < minRight) rightDays = minRight;
          }
          if (rightDays < 0) rightDays = 0;
          newRight = rightDays * dayPx;
          if (newRight < newLeft) newRight = newLeft;
        }
        if (isMilestoneDrag && mode==='move'){
          newRight = newLeft + baseSpanPx;
        }
        var widthPx = isMilestoneDrag ? Math.max(MILESTONE.size, Math.max(0, baseSpanPx)) : Math.max(16, newRight - newLeft);
        node.style.left  = newLeft + 'px';
        node.style.width = widthPx + 'px';
        node.__left = newLeft;
        node.__right = isMilestoneDrag ? (newLeft + baseSpanPx) : newRight;

        if (mode === 'move'){
          lastShiftDays = shiftDays;
          if (multiMeta && multiMeta.length > 1){
            var shiftPx = shiftDays * dayPx;
            multiMeta.forEach(function(meta){
              if (meta.id === id) return;
              if (!meta.node) return;
              var mLeft = meta.baseLeft + shiftPx;
              var spanPx = meta.baseSpanPx;
              var targetWidth = meta.isMilestone ? Math.max(MILESTONE.size, Math.max(0, spanPx)) : Math.max(16, spanPx);
              meta.node.style.left = mLeft + 'px';
              meta.node.style.width = targetWidth + 'px';
              meta.node.__left = mLeft;
              meta.node.__right = meta.isMilestone ? (mLeft + spanPx) : (mLeft + spanPx);
            });
          }
        }

        if (isMilestoneDrag){
          var newEndStr = tl.xToDate(newLeft);
          var tipMs = (t ? t.title : 'Task') + ' : ' + newEndStr;
          showTip(tipMs, ev.clientX, ev.clientY);
        } else {
          // Live tooltip of new date range
          var newStart = tl.xToDate(newLeft);
          var spanDays = (mode==='move')
            ? Math.max(1, baseSpanDays)
            : Math.max(1, Math.round((newRight - newLeft)/dayPx));
          var newEnd = fmt(addDays(new Date(newStart), spanDays - 1));
          var tip = (t ? t.title : 'Task') + ' : ' + newStart + ' ~ ' + newEnd;
          showTip(tip, ev.clientX, ev.clientY);
        }
      }

      function onUp(ev){
        if (!mode) return;
        var t = state.tasks.find(function(t){return t.id===id;});
        if (t){
          var newLeft  = (node.__left!=null)? node.__left : parseInt(node.style.left,10);
          var newRight = (node.__right!=null)? node.__right: (newLeft + parseInt(node.style.width,10));
          var appliedShiftDays = 0;
          if (isMilestoneDrag){
            var newEndStr = tl.xToDate(newLeft);
            var shiftDays = (baseTaskEnd!=null) ? dateSpanDays(baseTaskEnd, newEndStr) : 0;
            if (baseTaskStart!=null){ t.start = fmt(addDays(new Date(baseTaskStart), shiftDays)); }
            t.end = newEndStr;
            if (mode === 'move') appliedShiftDays = shiftDays;
          } else {
            var start = tl.xToDate(newLeft);
            var spanDays = (mode==='move')
              ? Math.max(1, Math.round((baseRight - baseLeft)/tl.pxPerDay))
              : Math.max(1, Math.round((newRight - newLeft)/tl.pxPerDay));
            var end   = fmt(addDays(new Date(start), spanDays - 1));
            t.start = start; t.end = end;
            if (mode === 'move' && baseTaskStart!=null){
              appliedShiftDays = dateSpanDays(baseTaskStart, t.start);
            }
          }

          if (!multiMeta || multiMeta.length <= 1){
            var y = ev.clientY;
            for (var i=0;i<rcList.length;i++){
              var r = rcList[i];
              if (y >= r.rect.top && y <= r.rect.bottom){
                var dropLane = r.laneId;
                if (dropLane && dropLane !== t.laneId){ t.laneId = dropLane; selectedLaneId = dropLane; }
                break;
              }
            }
          }

          ensureRangeCovers(t.start, t.end);

          if (mode === 'move' && appliedShiftDays === 0 && lastShiftDays){
            appliedShiftDays = lastShiftDays;
          }

          if (mode === 'move' && multiMeta && multiMeta.length > 1){
            multiMeta.forEach(function(meta){
              if (meta.id === id) return;
              if (!meta.task) return;
              if (!meta.baseEnd) meta.baseEnd = meta.task.end;
              if (!meta.baseStart) meta.baseStart = meta.task.start;
              if (appliedShiftDays === 0) return;
              if (meta.isMilestone){
                var newMetaEnd = fmt(addDays(new Date(meta.baseEnd), appliedShiftDays));
                meta.task.end = newMetaEnd;
                if (meta.baseStart){
                  meta.task.start = fmt(addDays(new Date(meta.baseStart), appliedShiftDays));
                }
              } else {
                meta.task.start = fmt(addDays(new Date(meta.baseStart), appliedShiftDays));
                meta.task.end = fmt(addDays(new Date(meta.baseEnd), appliedShiftDays));
              }
              ensureRangeCovers(meta.task.start, meta.task.end);
            });
          }

          markDirty('Autosaved'); render();
        } else { undoStack.pop && undoStack.pop(); }

        mode = null;
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        dragActive = false; hideTip();
      }

      window.addEventListener('mousemove', onMove, { passive:false });
      window.addEventListener('mouseup', onUp, { passive:true });
    });

    // Touch support
    node.addEventListener('touchstart', function(e){
      if (!e.touches || !e.touches[0]) return;
      var t0 = e.touches[0];
      var withinLeft = e.target.classList.contains('left');
      var withinRight = e.target.classList.contains('right');
      mode = withinLeft ? 'left' : (withinRight ? 'right' : 'move');
      startX = t0.clientX;

      var t = state.tasks.find(function(tt){return tt.id===id;});
      var lane = t ? state.lanes.find(function(l){ return l.id===t.laneId; }) : null;
      isMilestoneDrag = isTaskMilestone(t, lane);
      baseTaskStart = t ? t.start : null;
      baseTaskEnd = t ? t.end : null;
      if (isMilestoneDrag && t){
        baseLeft  = tl.dateToX(t.end);
        baseRight = baseLeft + (MILESTONE && MILESTONE.size ? MILESTONE.size : 18);
      } else if (t){
        baseLeft  = tl.dateToX(t.start);
        baseRight = tl.dateToX(fmt(addDays(new Date(t.end),1)));
      } else {
        baseLeft = baseRight = 0;
      }
      baseSpanPx = baseRight - baseLeft;

      hideTip(); selectTaskNoRender(id); e.preventDefault(); dragActive = true;
      pushUndo();
      var rcList = rowsCache();
      var step = tl.stepPx;

      function onMoveTouch(ev){
        if (!mode) return;
        if (!ev.touches || !ev.touches[0]) return;
        var dx = ev.touches[0].clientX - startX;
        var newLeft = baseLeft, newRight = baseRight;
        if (state.scale === 'month'){
          if (mode==='move'){
            var weekly = 7 * tl.pxPerDay;
            var shift = Math.round(dx / weekly) * weekly;
            newLeft  = Math.max(0, baseLeft + shift);
            newRight = Math.max(newLeft, newLeft + (baseRight - baseLeft));
          } else if (mode==='left'){
            newLeft = tl.nearestMonthPx(baseLeft + dx);
            if (newLeft > baseRight) newLeft = baseRight;
            newRight = baseRight;
          } else if (mode==='right'){
            newRight = tl.nearestMonthPx(baseRight + dx);
            if (newRight < baseLeft) newRight = baseLeft;
            newLeft = baseLeft;
          }
        } else {
          if (mode==='move'){
            newLeft  = Math.max(0, Math.round((baseLeft  + dx)/step)*step);
            newRight = Math.max(0, Math.round((baseRight + dx)/step)*step);
          } else if (mode==='left'){
            newLeft = Math.max(0, Math.round((baseLeft + dx)/step)*step);
            if (newLeft > baseRight) newLeft = baseRight;
          } else if (mode==='right'){
            newRight = Math.max(0, Math.round((baseRight + dx)/step)*step);
            if (newRight < baseLeft) newRight = baseLeft;
          }
        }
        if (isMilestoneDrag && mode==='move'){
          newRight = newLeft + baseSpanPx;
        }
        var widthPx = isMilestoneDrag ? Math.max(MILESTONE.size, Math.max(0, baseSpanPx)) : Math.max(16, newRight - newLeft);
        node.style.left  = newLeft + 'px';
        node.style.width = widthPx + 'px';
        node.__left = newLeft;
        node.__right = isMilestoneDrag ? (newLeft + baseSpanPx) : newRight;
        // Live tooltip for touch
        if (isMilestoneDrag){
          var newEndStr = tl.xToDate(newLeft);
          var deltaDays = (baseTaskEnd!=null) ? dateSpanDays(baseTaskEnd, newEndStr) : 0;
          var shiftedStart = (baseTaskStart!=null) ? fmt(addDays(new Date(baseTaskStart), deltaDays)) : newEndStr;
          var tipMs = (t ? t.title : 'Task') + ' : ' + shiftedStart + ' ~ ' + newEndStr;
          showTip(tipMs, ev.touches[0].clientX, ev.touches[0].clientY);
        } else {
          var newStart = tl.xToDate(newLeft);
          var spanDays = (mode==='move')
            ? Math.max(1, Math.round((baseRight - baseLeft)/tl.pxPerDay))
            : Math.max(1, Math.round((newRight - newLeft)/tl.pxPerDay));
          var newEnd = fmt(addDays(new Date(newStart), spanDays - 1));
          var tip = (t ? t.title : 'Task') + ' : ' + newStart + ' ~ ' + newEnd;
          showTip(tip, ev.touches[0].clientX, ev.touches[0].clientY);
        }
        ev.preventDefault();
      }

      function onUpTouch(ev){
        var cy = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientY : 0;
        if (!mode) return;
        var tt = state.tasks.find(function(x){return x.id===id;});
        if (tt){
          var newLeft  = (node.__left!=null)? node.__left : parseInt(node.style.left,10);
          var newRight = (node.__right!=null)? node.__right: (newLeft + parseInt(node.style.width,10));
          if (isMilestoneDrag){
            var newEndStr = tl.xToDate(newLeft);
            var shiftDays = (baseTaskEnd!=null) ? dateSpanDays(baseTaskEnd, newEndStr) : 0;
            if (baseTaskStart!=null){ tt.start = fmt(addDays(new Date(baseTaskStart), shiftDays)); }
            tt.end = newEndStr;
          } else {
            var start = tl.xToDate(newLeft);
            var spanDays = Math.max(1, Math.round((newRight - newLeft)/tl.pxPerDay));
            var end   = fmt(addDays(new Date(start), spanDays - 1));
            tt.start = start; tt.end = end;
          }
          var y = cy;
          for (var i=0;i<rcList.length;i++){
            var r = rcList[i];
            if (y >= r.rect.top && y <= r.rect.bottom){
              var dropLane = r.laneId;
              if (dropLane && dropLane !== tt.laneId){ tt.laneId = dropLane; selectedLaneId = dropLane; }
              break;
            }
          }
          ensureRangeCovers(tt.start, tt.end); markDirty('Autosaved'); render();
        } else { undoStack.pop && undoStack.pop(); }

        mode = null;
        window.removeEventListener('touchmove', onMoveTouch);
        window.removeEventListener('touchend', onUpTouch);
        dragActive = false; hideTip();
      }

      window.addEventListener('touchmove', onMoveTouch, { passive:false });
      window.addEventListener('touchend', onUpTouch, { passive:true });
    }, { passive:false });
  }

  /* ========= Task Edit Modal ========= */
  function openTaskEditor(taskId){
    var task = state.tasks.find(function(t){return t.id===taskId;});
    if (!task || modalOpen) return;
    modalOpen = true;

    hideTip();

    var laneOfTask = state.lanes.find(function(l){ return l.id===task.laneId; });
    var taskMilestone = isTaskMilestone(task, laneOfTask);

    var wrap = document.createElement('div');
    wrap.className='rm-backdrop';
    wrap.style.position='fixed'; wrap.style.inset='0';
    wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.justifyContent='center';
    wrap.style.background='rgba(0,0,0,0.32)'; wrap.style.zIndex='2147483000';

    var dialog = document.createElement('div');
    dialog.className='rm-modal';
    dialog.innerHTML = ''
      + '<header>편집: Task</header>'
      + '<div class="rm-body">'
      +   '<label for="rm-ed-title">작업 이름</label>'
      +   '<input id="rm-ed-title" type="text" value="'+escapeHtml(task.title)+'" />'
      +   '<label for="rm-ed-owner">담당자</label>'
      +   '<input id="rm-ed-owner" type="text" value="'+escapeHtml(task.owner || '')+'" placeholder="이 작업의 담당자를 입력하세요" />'
      +   '<label for="rm-ed-start">작업일정</label>'
      +   '<div class="rm-date-range">'
      +     '<input id="rm-ed-start" type="date" value="'+task.start+'" />'
      +     '<span>~</span>'
      +     '<input id="rm-ed-end" type="date" value="'+task.end+'" aria-label="종료일" />'
      +   '</div>'
      +   '<label for="rm-ed-usecolor">색상</label>'
      +   '<div class="rm-option-group">'
      +     '<label class="rm-option-row">'
      +       '<input id="rm-ed-usecolor" type="checkbox" /> 개별 색상 지정'
      +       '<input id="rm-ed-color" type="color" class="rm-color-picker" />'
      +     '</label>'
      +   '</div>'
      +   '<label for="rm-ed-milestone">마일스톤</label>'
      +   '<div class="rm-option-group">'
      +     '<label class="rm-option-row">'
      +       '<input id="rm-ed-milestone" type="checkbox"'+(taskMilestone?' checked':'')+' /> 이 작업을 마일스톤으로 표시'
      +     '</label>'
      +   '</div>'
      + '</div>'
      + '<footer>'
      +   '<button class="rm-btn" id="rm-ed-cancel">취소 (Esc)</button>'
      +   '<button class="rm-btn" id="rm-ed-save">저장 (Enter)</button>'
      + '</footer>';

    wrap.appendChild(dialog);
    document.body.appendChild(wrap);

    var $t = dialog.querySelector('#rm-ed-title');
    var $owner = dialog.querySelector('#rm-ed-owner');
    var $s = dialog.querySelector('#rm-ed-start');
    var $e = dialog.querySelector('#rm-ed-end');
    var $save = dialog.querySelector('#rm-ed-save');
    var $cancel = dialog.querySelector('#rm-ed-cancel');
    var $useC = dialog.querySelector('#rm-ed-usecolor');
    var $col = dialog.querySelector('#rm-ed-color');
    var $milestone = dialog.querySelector('#rm-ed-milestone');

    function bindDateInput(input){
      if (!input) return;
      input.addEventListener('pointerdown', function(){ if (input.showPicker) input.showPicker(); });
      input.addEventListener('keydown', function(ev){
        if (ev.key === ' ' && input.showPicker){ ev.preventDefault(); input.showPicker(); }
      });
    }
    bindDateInput($s);
    bindDateInput($e);

    // init color controls
    var initColor = task.color || (laneOfTask && laneOfTask.color) || '#e5e7eb';
    $col.value = initColor;
    $useC.checked = !!task.color;
    $col.disabled = !$useC.checked;
    $useC.addEventListener('change', function(){ $col.disabled = !$useC.checked; });

    function close(){ wrap.parentNode.removeChild(wrap); modalOpen=false; }
    function doSave(){
      pushUndo();
      var title = ($t.value||'').trim() || 'Untitled';
      var sVal = $s.value || task.start;
      var eVal = $e.value || task.end;
      if (eVal < sVal){ var tmp=sVal; sVal=eVal; eVal=tmp; }
      var ownerVal = ($owner && $owner.value) ? $owner.value.trim() : '';
      task.title=title; task.start=sVal; task.end=eVal;
      if (ownerVal){ task.owner = ownerVal; } else { delete task.owner; }
      if ($useC.checked){ task.color = $col.value; } else { delete task.color; }
      if ($milestone){ task.milestone = !!$milestone.checked; }
      ensureRangeCovers(task.start, task.end);
      markDirty('Autosaved'); close(); render();
    }

    $save.addEventListener('click', function(e){ e.stopPropagation(); doSave(); });
    $cancel.addEventListener('click', function(e){ e.stopPropagation(); close(); });

    wrap.addEventListener('keydown', function(ev){
      if (ev.key === 'Enter'){ ev.preventDefault(); ev.stopPropagation(); doSave(); }
      if (ev.key === 'Escape'){ ev.preventDefault(); ev.stopPropagation(); close(); }
    });
    wrap.addEventListener('mousedown', function(ev){ if (ev.target === wrap) close(); });
    setTimeout(function(){ $t.select(); }, 0);
  }

  /* ========= Global Keys ========= */
  var keySeq='', keySeqAt=0;
  function feedSeq(ch){
    var now=Date.now();
    if (now - keySeqAt > 700) keySeq='';
    keySeq += ch; if (keySeq.length>2) keySeq=keySeq.slice(-2);
    keySeqAt=now; return keySeq;
  }

  if (!window.__rm_keys_bound){
    window.addEventListener('keydown', function(e){
      if (!isTypingContext()){
        if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z' && !e.shiftKey){ e.preventDefault(); doUndo(); return; }
        if ((e.ctrlKey||e.metaKey) && (e.key.toLowerCase()==='y' || (e.key.toLowerCase()==='z' && e.shiftKey))){ e.preventDefault(); doRedo(); return; }
      }
      if (modalOpen) return;

      if (e.key==='Enter' && selectedTaskId && !isTypingContext()){ e.preventDefault(); openTaskEditor(selectedTaskId); }
      if (e.key==='Insert' && selectedLaneId && !isTypingContext()){
        e.preventDefault();
        createTask(selectedLaneId, { end: fmt(addDays(today(),0)), openEditor: true });
      }
      if (e.key==='Delete' && selectedTaskIds.length && !isTypingContext()){
        e.preventDefault();
        deleteSelectedTask();
      }
      if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='c' && selectedTaskId && !isTypingContext()){
        e.preventDefault();
        copySelectedTask();
      }
      if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='v' && selectedLaneId && !isTypingContext()){
        if (pasteTaskIntoLane(selectedLaneId)){
          e.preventDefault();
        }
      }
      if (!isTypingContext() && selectedLaneId && (e.key==='-' || e.key==='+')){
        var seq = feedSeq(e.key);
        var lane = state.lanes.find(function(l){return l.id===selectedLaneId;});
        if (!lane) return;
        if (seq==='--'){ e.preventDefault(); pushUndo(); lane.collapsed=true;  markDirty('Autosaved'); render(); keySeq=''; }
        if (seq==='++'){ e.preventDefault(); pushUndo(); lane.collapsed=false; markDirty('Autosaved'); render(); keySeq=''; }
      } else if (['Shift','Control','Meta','Alt'].indexOf(e.key)===-1){
        keySeq='';
      }
    });
    window.__rm_keys_bound = true;
  }

  /* ========= Boot ========= */
  (function boot(){
    $.status.textContent = 'Loading…';
    loadFromAttachment().then(function(att){
      if (att){ state = att; $.status.textContent = 'Loaded from attachment'; }
      else {
        var loc = loadFromLocal();
        if (loc){ state = loc; $.status.textContent = 'Loaded from local'; }
        else { state = JSON.parse(JSON.stringify(DEFAULT)); $.status.textContent = 'New (template)'; }
      }

      var laneById = {};
      state.lanes.forEach(function(l){
        if (l.parentId === undefined) l.parentId = null;
        if (l.collapsed === undefined) l.collapsed = false;
        if (l.milestone === undefined) l.milestone = false;
        laneById[l.id] = l;
      });
      if (state.tasks && state.tasks.length){
        state.tasks.forEach(function(t){
          var laneRef = laneById[t.laneId];
          if (t.milestone === undefined){
            t.milestone = !!(laneRef && laneRef.milestone);
          } else {
            t.milestone = !!t.milestone;
          }
        });
      }
      Object.keys(laneById).forEach(function(id){ laneById[id].milestone = false; });

      if (state.scale==='week'){
        var s = ceilToMonday(new Date(state.start));
        state.start = fmt(s);
        state.end = fmt(addDays(s,35));
      }
      if (state.scale==='month'){
        var m = startOfMonth(new Date(state.start));
        state.start = fmt(m);
        state.end = fmt(endOfMonth(addDays(m,60)));
      }
      if (state.scale==='quarter'){
        var q = startOfQuarter(new Date(state.start));
        state.start = fmt(q);
        state.end = fmt(endOfQuarter(addDays(q, 270)));
      }
      if (state.scale==='year'){
        var y0 = startOfYear(new Date(state.start));
        state.start = fmt(y0);
        state.end = fmt(endOfYear(addDays(y0, 365))); 
      }

      // If there are tasks at load, fit range to cover all
      if (state.tasks && state.tasks.length){
        fitRangeToAllTasks();
      }

      selectedLaneId = state.lanes[0] ? state.lanes[0].id : null;
      if (typeof state.laneWidth !== 'number' || isNaN(state.laneWidth)) state.laneWidth = null;

      render();

      var tl = getTimeline();
      var x = tl.dateToX(fmt(today()));
      $.canvasWrap.scrollLeft = Math.max(0, x - ($.canvasWrap.clientWidth * 0.4));
      requestSync();
    }).catch(function(e){
      console.error(e);
      $.status.innerHTML = 'Load error <span class="rm-danger">(open console)</span>';
      state = JSON.parse(JSON.stringify(DEFAULT));
      render();
    });
  })();
})();
/*]]>*/
</script>
